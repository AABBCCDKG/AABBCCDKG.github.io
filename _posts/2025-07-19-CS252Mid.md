---
layout: post
title: CS252 Mid
date: 2025-07-19 15:32:13
description: LeetCode problems related to Backtracking
tags: LeetCode
categories: LeetCode
tabs: true
---
Premature Free: 过早释放内存
```C++
int *p = malloc(sizeof(int));
*p = 6; //将分配到内存中的值设置为6, p指针的值是*p = 6
free(p); //释放内存后，p虽然依然指向那块地址，但内存属于操作系统管理，p成为了一个悬空指针(dangling pointer)，不是free(*p)，因为p是指存储的地址，*p是p存储的地址里保存的值
printf("%d\n", *p);
```

Double Free
```C++
int *p = malloc(sizeof(int));
*p = 6;
free(p);
//free(p)后，p是dangling pointer,为了防止滥用，通常要加上p = NULL，手动清空指针
free(p);
```

Wild Free
```C++
int *p = malloc(sizeof(int));
*p = 6;
free(&p); // 释放了栈上的地址(指针本身的地址)，应该是free(p)
```

```C++
int *p = malloc(sizeof(int));
*p = 6;
p = p + 1
free(p); //释放的并不是原始malloc返回的地址
```

Memory Smashing (Heap Buffer Overflow)
```C++
int *g = malloc(20 * sizeof(int)); //将指针看成一个数组，length = 20
g[20] = 40; //index <= 19
free(g);
```

Memory Leak:
```C++
int g = new int;
// new和malloc差不多，&g是指针本身的地址，g是存储值的地址，*g是值
//malloc靠free(g)来释放内存，new靠delete g来释放内存
*g = 40;
int g = new int;
*g = 41;
delete g;
```
```C++
int *g = malloc(sizeof(int));
*g = 6;
g = NULL;//原来存储6的地址丢失，永远无法有效free(g)
```