---
layout: post
title: Binary Tree, LeetCode
date: 2025-06-15 15:32:13
description: LeetCode problems related to Tree
tags: LeetCode
categories: LeetCode
tabs: true
---
Full Binary Tree (Proper Binary Tree)

- every node has either exactly two children or no children.

Perfect Binary Tree (Strictly Full Binary Tree):

- Every internal node has two children
- All leaf nodes appear at the same depth(level).
- Level (k) start from 0
    - Every level has `2^k` nodes (Level(k) start from 0).
    - Total nodes: `2^(k+1) - 1`.
- Level (k) start from 1
    - Every level has `2^(k - 1)`. nodes (Level(k) start from 0)
    - Total nodes: `2^(k) - 1`.

Complete Binary Tree:

- Every level, except possibly the last, is completely filled.
- In the last level, all nodes are as far left as possible, with no “gaps” between them.
- heap is a complete binary tree.

Binary Search Tree:
- Average case for search and insert: O(log n) when the tree is approximately balanced (each comparison eliminates about half of the remaining nodes).
- Worst case for search and insert: O(n) if the tree becomes completely unbalanced (degenerates into a chain).
- Left -> Small, Top -> Medium, Right -> Big
- No requirement for node structure

Balanced Binary Search Tree:
- ∀ N: height(N.left) – height(N.right) ≤ 1
- the basic of map and set (the key in map and the element in set is in order)

```python
# Initialization by Linked List:
class ListNode:
    def __init__(self, val = 0, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right

# Initialization by List:
list = []
curr: list[index] 
left_children: list[2 * index + 1]
right_children: list[2 * index + 2]
```
Using backtracking to build binary tree
```python
class ListNode:
    def __init__(self, val = 0, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right

nums = [1, 2, 3, 4, 5]
def list_to_complete_binary_tree(nums: List[int], i = 0):
    if i > len(nums) - 1:
        return
    node = ListNode(nums[i])
    node.left = list_to_complete_binary_tree(nums, i * 2 + 1)
    node.right = list_to_complete_binary_tree(nums, i * 2 + 2)
    return node
```

DFS:
```python
# result should be the input of dfs, so that every recursive call will write into the same list
# pre-order
def dfs(self, result, root):
    if not root:
        return
    result.append(root.val) # middle
    left_branch = dfs(result, root.left) # left
    right_branch = dfs(result, root.right) # right
    return result
```
BFS
```python
from collections import deque
def bfs(self, root):
    if not root:
        return []
    queue = deque([root]) # queue stores node instead of the value of node
    result = []
    while queue:
        length_of_level = len(queue)
        level = []
        for i in range(length_of_level):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    return result
```

[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)
```python
# 1: _dfs accept result as input
class Solution:
    def preorderTraversal(self, root: Optional[List]) -> List[int]:
        return self._dfs(result = [], root = root) if root else []
    
    def _dfs(self, result: List[int], root: Optional[List]) -> List[int]: 
        if not root:
            return # stop iteration
        result.append(root.val)
        left_branch = self._dfs(result, root.left)
        right_branch = self._dfs(result, root.right)
        return result
        
# 2. _dfs doesn't accept result as input
class Solution:
    def preorderTraversal(self, root: Optional[List]) -> List[int]:
        if not root:
            return [] # return value
        left = self.preorderTraversal(root.left) # return the value of left_branch
        right = self.preorderTraversal(root.right)
        return [root.val] + left + right # left and right are all list 
```