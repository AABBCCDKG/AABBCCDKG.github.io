---
layout: post
title: Array
date: 2025-06-10 00:32:13
description: LeetCode problems related to Array
tags: LeetCode
categories: LeetCode
tabs: true
---
[704. Binary Search](https://leetcode.com/problems/binary-search/description/)

To calculate the middle index: use `(left + right) // 2`, where `//` denotes floor division. When the number of elements is even, the fomular returns the left-middle index.

Optimization: `left + (right - left) // 2` - Avoid integer overflow caused by a too large `right + left` through interval offset

Why O(log(n))?
- Each iteration eliminates half of elements
- Search Space shrinks exponentially
    - 1st iteration: n elements
    - 2st iteration: n/2 elements
- At most log(n) comparisons are needed
    - 2^k = n, log(n) = k
- Stop in advance (`nums[middle] == target`) before checking all search space (`left == right`)

```python
from typing import List
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left <= right:
            middle = left + (right - left)//2
            if target < nums[middle]: 
                # target is smaller, search the left half and update the right boundary
                right = middle - 1
            elif target > nums[middle]: 
                # target is bigger, search the right half and update the left boundary
                left = middle + 1
            else:
                return middle
        return -1
```

[27. Remove Element](https://leetcode.com/problems/remove-element/description/)

Run test cases:
```python
a = [1, 2, 3]
b = [2, 3, 4]
for i in range(len(a)):
    assert a[i] == b[i] # assertion error
```

The algorithm aims to remove elements. Using `nums[j] == val` finds elements to delete, but deletion is essentially "doing nothing". The elements that actually need operations are those where `nums[j] != val` (preserve and move postions)

```python
from typing import List
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != val: # we need to do some operations 
                nums[slow] == nums[fast]
                slow += 1
        return slow
```

[977. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/description/)

```python
# left, right pointers:
left = 0
right = len(nums) - 1
while left <= right:
    # dynamic boundaries
    # last iteration: left == right (can terminate early)
```

```python
# slow, fast pointers:
slow = 0
for fast in range(len(nums)):
    # complete traversal (counldn't terminate early)
```

In-place: algorithms that do not use additional data structures to stroe data during execution, but instead modify the original input data structure directly.

Space Complexity:
 - In-place: O(1)
 - Not in-place: O(n), addtional array   

Why not in-place in this question?
 - Position changes are very complex (lacking a fixed direction or fixed pattern). Cross movements are difficult to accomplish with simple (two) pointer opertaions

```python
from typing import List
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        left = 0
        right = len(nums) - 1
        result = [0] * len(nums)
        position = len(nums) - 1
        while left <= right:
            left_square = nums[left] ** 2
            right_square = nums[right] ** 2
            if left_square < right_square:
                result[position] = right_square
                position -= 1
                right -= 1
            else:
                reslut[position] = left_square
                position -= 1
                left += 1
        return result
```


