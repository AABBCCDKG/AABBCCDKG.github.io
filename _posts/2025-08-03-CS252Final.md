---
layout: post
title: CS252 Final
date: 2025-08-03 15:32:13
description: LeetCode problems related to Backtracking
tags: LeetCode
categories: LeetCode
tabs: true
---
`A | B`: `A`的输出是`B`的输入，比如`cat infile.txt | grep hello`
- 在`C`程序中，模拟`bash`的重定向和管道等行为，一定会用到`fork()` + `dup2()` + `pipe()`
    - `A | B`
        - `pipe()`创建一个管道
        - `fork()`创建两个子进程(执行A和B)
        - `dup2()`把`A`的`stdout`->管道写端, `B`的`stdin`<-管道读端
        - `exec()`分别执行`A`和`B`命令, 一般是`execvp(命令, 参数)`, `execlp()`等
    - `< file`
        - `open(file, O_RDONLY)`打开文件
        - `dup2(fd, STDIN_FILENO)`把文件重新定向为标准输入(通常放在fork后的子进程中)
    - `> file`
        - `open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644)`打开文件
        - `dup2(fd, STDOUT_FILENO)`把文件重新定向为标准输出
    - `>> file`
        - `open(file, O_WRONLY | O_CREAT | O_APPEND, 0644)`打开文件
        - `dup2(fd, STDOUT_FILENO)`把文件重新定向为标准输出
```C
//A, B是命令, argvA/argvB是参数组
void redirect(const char * A, char *const argvA[], const char * B, char *const argvB[]) {
    // A | B
    int fd[2];
    if(pipe(fd) == -1){
        perror("pipe");
        exit(1);
    };

    int pid1 = fork();
    if (pid1 == -1) {
        perror("fork1");
        exit(1);
    }
    if (pid1 == 0) {
        // handle A
        close(fd[0]);
        dup2(fd[1], 1); //STDOUT这个宏不存在，用1代替
        close(fd[1]); //重新定向后就可以关闭
        execvp(A, argvA); //一般后面直接加perror
        perror("exec A");
        exit(1);
    }

    int pid2 = fork();
    if (pid2 == -1) {
        perror("fork2");
        exit(1);
    }
    if (pid2 == 0){
        // handle B
        close(fd[1]);
        dup2(fd[0], 0); //STDIN这个宏也不存在，用0代替
        close(fd[0]); //重新定向后就可以关闭
        execvp(B, argvB);
        perror("exec B");
        exit(1);
    }

    //在父进程中，关闭所有pip端并等待两个子进程
    close(fd[0]); //不关闭读端，写端就会一直挂着
    close(fd[1]);
    waitpid(pid1, NULL, 0);
    waitpid(pid2, NULL, 0);
}
```

```C
// < file
void redirectToFile(const char * file) {
    int fd = open(file, O_RDONLY); // 不需要管道，所以不是int fd[2], 只要用open(file, O_RDONLY)就可以
    if (fd == -1) {
        perror("file open failed");
        exit(1);
    }
    if (dup2(fd, STDIN_FILENO) == -1) {
        perror("dup2 failed");
        exit(1);
    }
    close(fd); //最后依然是关闭
}
```
```C
// > file
void redirect(const char * file) {
    int fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("open failed");
        exit(1);
    }
    if (dup2(fd, STDOUT_FILENO) == -1) {
        perror("dup2 failed");
        exit(1);
    }
    close(fd);
}
```
```C
// >> file
void redirect(const char * file) {
    int fd = open(file, O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (fd == -1) {
        perror("open failed");
        exit(1);
    } 
    if (dup2(fd, STDOUT_FILENO) == -1) {
        perror("dup2 failed");
        exit(1);
    }
    close(fd);
}
```

`sort < file.txt`: 读取`file.txt`的内容并进行排序，等价于`cat file.txt | sort`

- `sort`从`stdin`读取指令: 
```C
char *argv[] = {"sort", NULL};
execvp("sort", argv);
```
- `sort`从`file.txt`读取指令:
```C
char *argv[] = {"sort", "file.txt", NULL};
execvp("sort", argv);
```
- `grep`从`stdin`读取指令:
```C
char *argv[] = {"grep", "hello", NULL};
execvp("grep", argv);
```
- `grep`从`file.txt`读取指令:
```C
char *argv[] = {"grep", "hello", "file.txt", NULL};
execvp("grep", argv);
```

```C
//sort < file.txt
void sortCommand(const char * file) {
    int fd = open(file, O_RDONLY);
    if (fd == -1) {
        perror("open file failed");
        exit(1);
    }
    if(dup2(fd, STDIN_FILENO) == -1){
        perror("dup2 failed");
        exit(1);
    }
    close(fd);

    char *argv[] = {"sort", NULL};
    execvp('sort', argv);
    perror("sort error");
    exit(1);
}
```

`grep A`: 从标准输入读取内容，并筛出包含`A`的行
```C
void grep(char * A){
    char * argv[] = {"grep", A, NULL};
    execvp("grep", argv);
    perror("exec fail");
    exit(1);
}
```

`command >> file.txt`: 追加重定向，把`command`输出追加到`file.txt`的结尾(不会覆盖原本的内容)
```C
void redirect(const char* command, const char* file){
    int fd = open(file, O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (fd == -1) {
        perror("open fail");
        exit(1);
    }
    if (dup2(fd, STDOUT_FILENO) == -1){
        perror("dup2 failed");
        exit(1);
    }
    close(fd);//不要忘记close
    char *argv[] = {(char *) command, NULL}; //不要写死，用command变量
    execvp(command, argv);
    perror("exec failed");
    exit(1);
}
```

`sort < infile.txt | grep hello >> output.txt`: 读取`file.txt`的内容并排序，从中找到包含`hello`的行，添加到`output.txt`的结尾
- sort:
    - 读取从STDIN 变成infile.txt
    - 输出从STDOUT变成pipeline写端
- grep:
    - 读取从STDIN变成pipeline读端
    - 输出从STDOUT变成output.txt
```C
//grepsort arg1 arg2 arg3 = sort < arg2 | grep arg1 >> arg3
//参数应该是, argv[0] = grepsort, argv[1] = arg1
void grepsort(char * argv[]){
    int fd[2]; //一个管道即可,因为只有一个管道符号 | 
    if (pipe(fd) == -1){
        perror("pipe failed");
        exit(1);
    }
    int pid1 = fork();
    //不要忘记检查fork
    if (pid1 == -1) {
        perror("fork1 failed");
        exit(1);
    }
    //fork成功，还有父子进程之分
    if (pid1 == 0){
        close(fd[0]);
        //子进程1: sort < infile.txt | -> 写入管道
        int fd_in = open(argv[2], O_RDONLY);
        if (fd_in == -1){
            perror("open infile failed");
            exit(1);
        }
        //这里的输入来自infile.txt, 输出是去管道，所以有两个dup2
        if(dup2(fd_in, STDIN_FILENO) == -1){
            // dup2(A, STDIN_FILENO): 标准输入来自A
            perror("dup2 from infile.txt failed");
            exit(1);
        }
        if(dup2(fd[1], STDOUT_FILENO) == -1){
            //标准输出来自fd[1]
            perror("dup2 to pipe failed");
            exit(1);
        }
        close(fd_in);
        close(fd[1]);

        char * argv1[] = {"sort", NULL};
        execvp("sort", argv1);
        perror("sort exec failed");
        exit(1);
    }

    int pid2 = fork();
    if (pid2 == -1) {
        perror("fork2 failed");
        exit(1);
    }
    if (pid2 == 0) {
        close(fd[1]);
        int fd_out = open(argv[3], O_WRONLY | O_CREAT | O_APPEND, 0644);
        if (fd_out == -1) {
            perror("open output failed");
            exit(1);
        }
        if(dup2(fd_out, STDOUT_FILENO) == -1){
            perror("dup2 for writing failed");
            exit(1);
        }
        if (dup2(fd[0], STDIN_FILENO) == -1){
            perror("dup2 for pipe reading failed");
            exit(1);
        }
        close(fd_out);
        close(fd[0]);

        char * argv2[] = {"grep", argv[1], NULL};
        execvp("grep", argv2);
        perror("grep exec failed");
        exit(1);
    }
    close(fd[0]);
    close(fd[1]);
    wait(pid1, NULL, 0);
    wait(pid2, NULL, 0);
}

```
`print entries`就是打印每一行的意思 `entries = lines`

`sort < infile.txt | grep hello >> output.txt`这本身就是一个`bash`命令，所以如果要用`program`来实现它，一定不是用`bash`，而是用`C`.

Question 2:
```C
int runCommand(char * command, char * outputBuffer, int maxBufferSize){
    int fd[2];
    if (pipe(fd) == -1) {
        perror("pipe failed");
        exit(1);
    }
    int pid = fork();
    if (pid == -1) {
        perror("fork failed");
        exit(1);
    }
    if (pid == 0){
        //child process:
        close(fd[0]);
        if(dup2(fd[1], STDOUT_FILENO) == -1){
            perror("dup2 failed");
            exit(1);
        }
        close(fd[1]);

        char * argv[] = {(char *)command, NULL};
        execvp(command, argv);
        perror("command exec failed");
        exit(1);
    } 
    close(fd[1]); //不写入管道任何东西，写入outputBuffer不等于写入管道
    int bytesRead = 0;
    int totalRead = 0;
    while ((bytesRead = read(fd[0], outputBuffer + totalRead, maxBufferSize - 1 - totalRead)) > 0) {
        totalRead += bytesRead;
        if (totalRead >= maxBufferSize - 1){
            break;
        }
    }
    close(fd[0]);
    //添加结束符
    outputBuffer[totalRead] = '\0';

    int status;
    wait(pid, &status, 0);
    return (bytesRead < 0 || !WIFEXITED(status)) ? -1 : 0;
}
```


Question3:

`make them synchronized`: 让他们变得线程安全

`insert()` -> 生产者; `removeFirst()` -> 消费者

`semaphores`: 信号量(资源计数器)
```C
struct List * head = NULL;
pthread_mutex_t mutexLock;
sema_t fullSem;
sema_t emptySem;

main(){
    pthread_mutext_init(&mutexLock, NULL);
    sema_init(&fullSem, 20, USYNC_THREAD, NULL);
    sema_init(&emptySem, 0, USYNC_THREAD, NULL);
}
```

Question 7:
