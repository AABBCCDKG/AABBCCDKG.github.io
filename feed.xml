<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://aabbccdkg.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://aabbccdkg.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-06-15T22:07:23+00:00</updated><id>https://aabbccdkg.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Binary Tree, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Tree/" rel="alternate" type="text/html" title="Binary Tree, LeetCode"/><published>2025-06-15T15:32:13+00:00</published><updated>2025-06-15T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Tree</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Tree/"><![CDATA[<p>Full Binary Tree (Proper Binary Tree)</p> <ul> <li>every node has either exactly two children or no children.</li> </ul> <p>Perfect Binary Tree (Strictly Full Binary Tree):</p> <ul> <li>Every internal node has two children</li> <li>All leaf nodes appear at the same depth(level).</li> <li>Level (k) start from 0 <ul> <li>Every level has <code class="language-plaintext highlighter-rouge">2^k</code> nodes (Level(k) start from 0).</li> <li>Total nodes: <code class="language-plaintext highlighter-rouge">2^(k+1) - 1</code>.</li> </ul> </li> <li>Level (k) start from 1 <ul> <li>Every level has <code class="language-plaintext highlighter-rouge">2^(k - 1)</code>. nodes (Level(k) start from 0)</li> <li>Total nodes: <code class="language-plaintext highlighter-rouge">2^(k) - 1</code>.</li> </ul> </li> </ul> <p>Complete Binary Tree:</p> <ul> <li>Every level, except possibly the last, is completely filled.</li> <li>In the last level, all nodes are as far left as possible, with no “gaps” between them.</li> <li>heap is a complete binary tree.</li> </ul> <p>Binary Search Tree:</p> <ul> <li>Average case for search and insert: O(log n) when the tree is approximately balanced (each comparison eliminates about half of the remaining nodes).</li> <li>Worst case for search and insert: O(n) if the tree becomes completely unbalanced (degenerates into a chain).</li> <li>Left -&gt; Small, Top -&gt; Medium, Right -&gt; Big</li> <li>No requirement for node structure</li> </ul> <p>Balanced Binary Search Tree:</p> <ul> <li>∀ N: height(N.left) – height(N.right) ≤ 1</li> <li>the basic of map and set (the key in map and the element in set is in order)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Initialization by Linked List:
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="c1"># Initialization by List:
</span><span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">curr</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> 
<span class="n">left_children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">right_children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div> <p>Using backtracking to build binary tree</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">list_to_complete_binary_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nf">list_to_complete_binary_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nf">list_to_complete_binary_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div> <p>DFS:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># result should be the input of dfs, so that every recursive call will write into the same list
# pre-order
</span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="c1"># middle
</span>    <span class="n">left_branch</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># left
</span>    <span class="n">right_branch</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1"># right
</span>    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p>BFS</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span> <span class="c1"># queue stores node instead of the value of node
</span>    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">length_of_level</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length_of_level</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">144. Binary Tree Preorder Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1: _dfs accept result as input
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> 
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># stop iteration
</span>        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">left_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="c1"># 2. _dfs doesn't accept result as input
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span> <span class="c1"># return value
</span>        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># return the value of left_branch
</span>        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="c1"># left and right are all list 
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/">145. Binary Tree Postorder Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__ini__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
    
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__ini__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
    
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>
<span class="c1"># Or
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="p">[]</span> <span class="c1"># in case _dfs only run the first two line code
</span>    
    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">left_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">94. Binary Tree Inorder Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">left_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">right_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
<span class="c1"># Or
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/">102. Binary Tree Level Order Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
    
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">length_of_level</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length_of_level</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/invert-binary-tree/description/">226. Invert Binary Tree</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span> <span class="c1"># Al
</span>        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span> 
            <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            <span class="c1"># Using parallel assignment in python 
</span>            <span class="c1"># temp = node.left
</span>            <span class="c1"># node.left = node.right
</span>            <span class="c1"># node.right = temp
</span>            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/symmetric-tree/description/">101. Symmetric Tree</a></p> <p><code class="language-plaintext highlighter-rouge">len(nums)</code> is even:</p> <ul> <li><code class="language-plaintext highlighter-rouge">len(nums) // 2</code> returns the left middle index.</li> <li><code class="language-plaintext highlighter-rouge">math.ceil(nums / 2)</code> returns the right middle index.</li> </ul> <p><code class="language-plaintext highlighter-rouge">len(nums)</code> is odd:</p> <ul> <li>both return the middle one</li> </ul> <p>queue could also store a tuple <code class="language-plaintext highlighter-rouge">(node.left, node.right)</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">right</span> <span class="ow">or</span> <span class="n">left</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">left</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">.</span><span class="n">right</span><span class="p">))</span> 
            <span class="c1"># compare whether the whole tree is symmetric
</span>            <span class="c1"># queue.append((left.left, left.right)): compare the left branch of left is symmetric or not
</span>            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">right</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">right</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">104. Maximum Depth of Binary Tree</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span> 
            <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">depth</span>
        <span class="c1"># In most problems, it doesn't matter whether 
</span>        <span class="c1"># you place operations like +1, updates, 
</span>        <span class="c1"># or returns at the beginning or end of a loop. 
</span>        <span class="c1"># Confused about the initial value of depth? move the position (beginning is more reasonable)
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/">111. Minimum Depth of Binary Tree</a></p> <p><code class="language-plaintext highlighter-rouge">leaf node</code>: both <code class="language-plaintext highlighter-rouge">node.left</code> and <code class="language-plaintext highlighter-rouge">node.right</code> are <code class="language-plaintext highlighter-rouge">None</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">depth</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/count-complete-tree-nodes/description/">222. Count Complete Tree Nodes</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">getDepth</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="n">depth_of_left_branch</span> <span class="o">=</span> <span class="nf">getDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># getDepth is the method in countNodes, no need for self when using getDepth in countNodes
</span>        <span class="n">depth_of_right_branch</span> <span class="o">=</span> <span class="nf">getDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">depth_of_left_branch</span> <span class="o">==</span> <span class="n">depth_of_right_branch</span><span class="p">:</span>
            <span class="c1"># the left branch is full
</span>            <span class="k">return</span> <span class="mi">2</span><span class="o">^</span><span class="n">depth_of_left_branch</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> 
            <span class="c1"># + 1 is counting node itself
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the right branch is full
</span>            <span class="k">return</span> <span class="mi">2</span><span class="o">^</span><span class="n">depth_of_right_branch</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">counNodes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/balanced-binary-tree/description/">110. Balanced Binary Tree</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Some changes based on getDepth
        def getDepth(node):
            if not node:
                return 0
            left = getDepth(node.left)
            # could be filled for the operations on left branch
            right = getDepth(node.right)
            # could be filled for the operations on right branch

            # could be filled for the operation on current node
            return max(left, right) + 1
        </span><span class="sh">"""</span>
        <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            
            <span class="n">left</span> <span class="o">=</span> <span class="nf">check</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">right</span> <span class="o">=</span> <span class="nf">check</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">right</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

            <span class="k">if</span> <span class="nf">abs</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nf">check</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-paths/description/">257. Binary Tree Paths</a></p> <p><code class="language-plaintext highlighter-rouge">Process currnt node</code></p> <ul> <li>update the state <ul> <li>Add the node’s information into global state or the state passed as a parameter. <ul> <li>path problem: state.path.append(node.val)</li> <li>sum problems: state.sum += node.val</li> <li>min/max problems: state.best = max(state.best, node.val)</li> <li>graph visits: state.visited.add(node)</li> </ul> </li> </ul> </li> <li>Check or Record the result <ul> <li> <p>If the current state meets your goal, then save to your results list and optionally return/prune. ```python class ListNode: def <strong>init</strong>(self, val = 0, left = None, right = None): self.val = val self.left = left self.right = right class Solution: def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]: paths = [] def _dfs(path, node): # ending condition:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if not node.left and not node.right:
      path = path + '-&gt;' + str(node.val)
      paths.append(path)
  # left

  # right
</code></pre></div> </div> </li> </ul> </li> </ul>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Tree]]></summary></entry><entry><title type="html">NVIDIA, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Nvidia/" rel="alternate" type="text/html" title="NVIDIA, LeetCode"/><published>2025-06-14T16:32:13+00:00</published><updated>2025-06-14T16:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Nvidia</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Nvidia/"><![CDATA[<p><a href="https://leetcode.com/problems/product-of-array-except-self/description/?envType=company&amp;envId=nvidia&amp;favoriteSlug=nvidia-three-months">238. Product of Array Except Self</a></p> <p>When there are no elements to multiple at a certain position, the product should be initialized as <code class="language-plaintext highlighter-rouge">1</code>, since <code class="language-plaintext highlighter-rouge">1</code> is the identity element for multiplication and does not affect the overall result. That is the reason why <code class="language-plaintext highlighter-rouge">left_prod</code> and <code class="language-plaintext highlighter-rouge">right_prod</code> are both initialized as <code class="language-plaintext highlighter-rouge">1</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">productExceptSelf</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">left_prod</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">right_prod</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="c1"># append the left_prod first, update the left_prod with current element second to except self
</span>            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left_prod</span><span class="p">)</span>
            <span class="n">left_prod</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">right_prod</span>
            <span class="n">right_prod</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/group-anagrams/description/?envType=company&amp;envId=nvidia&amp;favoriteSlug=nvidia-three-months">49. Group Anagrams</a></p> <p>When you’re comparing elements in a list pairwise, <code class="language-plaintext highlighter-rouge">hashmap</code> could reduce the time complexity from <code class="language-plaintext highlighter-rouge">O(n^2)</code> to <code class="language-plaintext highlighter-rouge">O(n)</code> using a key with distinguishing or grouping capability.</p> <p><code class="language-plaintext highlighter-rouge">Anagram: same after sorting</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">groupAnagrams</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="c1"># sorted(word) will return a list
</span>            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">]</span>
        <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">hashmap</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span> 
        <span class="c1"># list(hashmap.keys())
</span>        <span class="c1"># list(hashmap.values()) 
</span>        <span class="c1"># list(hashmap.items()) List[tuple]
</span></code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems frequently asked by NVIDIA]]></summary></entry><entry><title type="html">Stack and Queue, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Stack-and-Queue/" rel="alternate" type="text/html" title="Stack and Queue, LeetCode"/><published>2025-06-14T15:32:13+00:00</published><updated>2025-06-14T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Stack-and-Queue</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Stack-and-Queue/"><![CDATA[<p><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">232. Implement Queue using Stacks</a></p> <p>Double stack (input stack and output stack) Transfer the element in input stack when output stack is empty</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">stack1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">stack2</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/implement-stack-using-queues/description/">225. Implement Stack using Queues</a></p> <p><code class="language-plaintext highlighter-rouge">Queue</code>:</p> <ul> <li>initialization: <code class="language-plaintext highlighter-rouge">q = deque()</code></li> <li><code class="language-plaintext highlighter-rouge">q.append()</code>, <code class="language-plaintext highlighter-rouge">q.popleft()</code></li> </ul> <p><code class="language-plaintext highlighter-rouge">List</code>:</p> <ul> <li>initialization: <code class="language-plaintext highlighter-rouge">l = []</code></li> <li><code class="language-plaintext highlighter-rouge">l.append()</code>, <code class="language-plaintext highlighter-rouge">l.pop()</code></li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">MyStack</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
    

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># there is no pop in the queue
</span>        <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">())</span>
            <span class="c1"># [1, 2, 3]
</span>            <span class="c1"># [2, 3, 1]
</span>            <span class="c1"># [3, 1, 2]
</span>            <span class="c1"># not reverse, just move the last element to the begining
</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span>    
</code></pre></div></div> <p><a href="https://leetcode.com/problems/valid-parentheses/description/">20. Valid Parentheses</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">(</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">)</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">[</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">]</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">{</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">}</span><span class="sh">'</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">char</span> <span class="o">!=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">():</span> <span class="c1"># stack should not be empty in advance
</span>                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">stack</span> <span class="c1"># stack should be empty exactly when iterate all char in s
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/">1047. Remove All Adjacent Duplicates In String</a></p> <p>The index of <code class="language-plaintext highlighter-rouge">0</code> of stack: the first element: <code class="language-plaintext highlighter-rouge">''.join(stack)</code> equals to <code class="language-plaintext highlighter-rouge">''.join(list)</code></p> <p>The index of <code class="language-plaintext highlighter-rouge">-1</code> of stack: the last element(top)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">char</span> <span class="o">==</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">()</span>
        <span class="k">return</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/">150. Evaluate Reverse Polish Notation</a></p> <p><code class="language-plaintext highlighter-rouge">if token in '+-*/'</code>: Check whether token is not one of the characters <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, or <code class="language-plaintext highlighter-rouge">/</code>.</p> <p><code class="language-plaintext highlighter-rouge">a // b</code>: floor division (only when there is no negative integer between <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>) <code class="language-plaintext highlighter-rouge">int(a/b)</code>: truncate toward zero</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">evalRPN</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span> <span class="c1"># the order of iteration is from index 0 to index len(tokens)
</span>            <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">+-*/</span><span class="sh">'</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span> <span class="o">*</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">left</span><span class="o">/</span><span class="n">right</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Stack and Queue]]></summary></entry><entry><title type="html">HashMap, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Hashmap/" rel="alternate" type="text/html" title="HashMap, LeetCode"/><published>2025-06-13T15:32:13+00:00</published><updated>2025-06-13T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Hashmap</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Hashmap/"><![CDATA[<p><a href="https://leetcode.com/problems/valid-anagram/description/">242. Valid Anagram</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">validAnagram</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">-=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/intersection-of-two-arrays/description/">349. Intersection of Two Arrays</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">hashmap</span> <span class="ow">and</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
<span class="c1"># find the intersection: list(set(nums1) &amp; set(nums2))
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/two-sum/description/">1. Two Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">hashmap</span><span class="p">[</span><span class="n">comp</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/4sum-ii/description/">454. 4Sum II</a></p> <p>Return the number of tuple, instead of listing all tuple</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fourSumCount</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">num2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">num3</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">num4</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">nums1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">nums2</span><span class="p">:</span>
                <span class="n">_sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">_sum</span><span class="p">]</span> <span class="o">=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">_sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nums3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nums4</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">target</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/4sum/description/">18. 4Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fourSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">nums</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
                    <span class="n">_sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">_sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">_sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]])</span>
                        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to HashMap]]></summary></entry><entry><title type="html">String, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/String/" rel="alternate" type="text/html" title="String, LeetCode"/><published>2025-06-13T15:32:13+00:00</published><updated>2025-06-13T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/String</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/String/"><![CDATA[<p><a href="https://leetcode.com/problems/reverse-string/description/">344. Reverse String</a></p> <p><code class="language-plaintext highlighter-rouge">return s[::-1]</code> will create a new reversed list and <code class="language-plaintext highlighter-rouge">s</code> is not changed</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseString</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/reverse-string-ii/description/">541. Reverse String II</a></p> <p><code class="language-plaintext highlighter-rouge">s[i:j]</code> equals <code class="language-plaintext highlighter-rouge">[i, j)</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseStr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nf">reversed</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/reverse-words-in-a-string/description/">151. Reverse Words in a String</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
s = </span><span class="sh">"</span><span class="s">  hello   world  </span><span class="sh">"</span><span class="s">
s.split() -&gt; [</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">world</span><span class="sh">'</span><span class="s">]
s.split(</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="s">) -&gt; [</span><span class="sh">''</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">'</span><span class="s">world</span><span class="sh">'</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">''</span><span class="s">]
</span><span class="sh">"""</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseWords</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span>
        <span class="k">return</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># return ''.join(reversed(s))
</span></code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to String]]></summary></entry><entry><title type="html">Mock Interview(1), LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Mock-Interview(1)/" rel="alternate" type="text/html" title="Mock Interview(1), LeetCode"/><published>2025-06-10T18:32:13+00:00</published><updated>2025-06-10T18:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Mock-Interview(1)</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Mock-Interview(1)/"><![CDATA[<p><a href="https://leetcode.com/problems/graph-valid-tree/description/">261. Graph Valid Tree</a></p> <p>A tree with <code class="language-plaintext highlighter-rouge">n</code> nodes must have exactly <code class="language-plaintext highlighter-rouge">n - 1</code> edges</p> <ul> <li>More than <code class="language-plaintext highlighter-rouge">n - 1</code>: cycle</li> <li>Less than <code class="language-plaintext highlighter-rouge">n - 1</code>: not all nodes are connected: isolated nodes or a forest (multiple disconnected subtrees)</li> </ul> <p>Union-Find, Find:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
 <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="c1"># when parent[x] == x, then it is the true root
</span>        <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> 
        <span class="c1"># find the true father node of x
</span>        <span class="c1"># since the father node of x is parent[x], the father node of parent[x] is parent[parent[x]]
</span>        <span class="c1"># then the true father node of x is parent[parent[x]]
</span>        <span class="c1"># x is not the root, but parent[x] and parent[parent[x]] may be the root
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> 
        <span class="c1"># update the x
</span>    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">validTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># [[1, 2]], [[1], [2]] all belongs to Lits[List[int]]
</span>        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="c1"># each node is own root
</span>        
        <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">x</span>
        
        <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">rootA</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">rootB</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

            <span class="c1"># if rootA = rootB, it means they already connected, there is a cycle
</span>            <span class="k">if</span> <span class="n">rootA</span> <span class="o">==</span> <span class="n">rootB</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span> 
            
            <span class="k">if</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootA</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootB</span><span class="p">]:</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">rootB</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootA</span> 
                <span class="c1"># update the parent root
</span>            <span class="k">else</span><span class="p">:</span> 
                <span class="n">parent</span><span class="p">[</span><span class="n">rootA</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootB</span>
                <span class="n">rank</span><span class="p">[</span><span class="n">rootA</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nf">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/3sum/description/">15. 3Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">threeSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nums</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span> <span class="c1"># the nums should be in order
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1"># Avoid duplicate group result in same element for i index
</span>            <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">_sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">_sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">_sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]])</span>

                    <span class="c1"># Avoid duplicate group result in same elements for left/right index
</span>                    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="c1"># check left &lt; right first to avoid list index out of range
</span>                        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/continuous-subarray-sum/description/?envType=company&amp;envId=facebook&amp;favoriteSlug=facebook-thirty-days">523. Continuous Subarray Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">origin_num</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">prefix_sum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
<span class="n">reminder_5</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                 <span class="o">|</span>     <span class="o">|</span>
                    <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div></div> <p>If a certain remainder of the prefix sum modulo <code class="language-plaintext highlighter-rouge">k</code> first appears at index <code class="language-plaintext highlighter-rouge">i</code> and then again at index <code class="language-plaintext highlighter-rouge">j</code>, then the subarray <code class="language-plaintext highlighter-rouge">(i, j]</code> has a sum that is divisible by k</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkSubarraySum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
        <span class="n">_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">_sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">_sum</span> <span class="o">%</span> <span class="n">k</span>
            
            <span class="k">if</span> <span class="n">remainder</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems discussed during a mock interview on 2025-06-10]]></summary></entry><entry><title type="html">Meta, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Meta/" rel="alternate" type="text/html" title="Meta, LeetCode"/><published>2025-06-10T16:32:13+00:00</published><updated>2025-06-10T16:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Meta</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Meta/"><![CDATA[<p><a href="https://leetcode.com/problems/buildings-with-an-ocean-view/description/?envType=company&amp;envId=facebook&amp;favoriteSlug=facebook-thirty-days">1762. Buildings With an Ocean View</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Wrong
</span><span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span> <span class="c1"># .sort() returns None
</span>
<span class="c1"># Correct: sort() is O(nlogn)
</span><span class="n">result</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
<span class="k">return</span> <span class="n">result</span>

<span class="c1"># Better: remove sort(), use [::-1] to reverse list, O(n)
</span><span class="k">return</span> <span class="n">result</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findBuildings</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">heights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">max_heights</span> <span class="o">=</span> <span class="n">heights</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_heights</span><span class="p">:</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">max_heights</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_heights</span><span class="p">,</span> <span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems frequently asked by Meta]]></summary></entry><entry><title type="html">Linked List, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/LinkedList/" rel="alternate" type="text/html" title="Linked List, LeetCode"/><published>2025-06-10T15:32:13+00:00</published><updated>2025-06-10T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/LinkedList</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/LinkedList/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="c1"># '=' assigns value
</span>        <span class="c1"># ':' type annotation
</span>        <span class="c1"># val: int = 0
</span>        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for doubly-linked list
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
        <span class="n">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span>
</code></pre></div></div> <p>Since ListNode may be <code class="language-plaintext highlighter-rouge">None</code>, so the type annotation should be Optional[ListNode]</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]):</span>
</code></pre></div></div> <p>Check <code class="language-plaintext highlighter-rouge">curr.next</code> for deletion of Linked List, so use <code class="language-plaintext highlighter-rouge">while curr.next</code> instead of <code class="language-plaintext highlighter-rouge">while curr</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeElements</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy_head</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dummy_head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">dummy_head</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
                <span class="c1"># curr.next is updated, check it 
</span>                <span class="c1"># again without moving curr forward 
</span>                <span class="c1"># otherwise, might skip consecutive target nodes.
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">dummy_head</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/design-linked-list/description/">707. Design Linked List</a></p> <p><code class="language-plaintext highlighter-rouge">return None</code> equals to <code class="language-plaintext highlighter-rouge">return</code> (end the function in advance)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
            <span class="n">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span>
    
    <span class="k">class</span> <span class="nc">MyLinkedList</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tail</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
            <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            
            <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span> 
            <span class="c1"># use self.head: iterate index + 1 times, i could be index
</span>            <span class="c1"># use self.head.next: iterate index times, 
</span>            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
                <span class="c1"># during this block, curr is the node at position i
</span>            <span class="k">return</span> <span class="n">curr</span><span class="p">.</span><span class="n">val</span>

        <span class="k">def</span> <span class="nf">addAtHead</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">addAtIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="c1"># no need for updating self.size
</span>        
        <span class="k">def</span> <span class="nf">addAtTail</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">addAtIndex</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="c1"># no need for updating self.size
</span>        
        <span class="k">def</span> <span class="nf">addAtIndex</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>

            <span class="n">pred</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">prev</span>
            <span class="n">suc</span> <span class="o">=</span> <span class="n">curr</span> <span class="c1"># move afterward, so suc is curr instead of curr.next
</span>            <span class="n">curr</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">pred</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="n">curr</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">pred</span>
            <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">suc</span>
            <span class="n">suc</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>
    
        <span class="k">def</span> <span class="nf">deleteAtIndex</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
            
            <span class="n">pred</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">prev</span>
            <span class="n">suc</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">pred</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">suc</span>
            <span class="n">suc</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">pred</span>
            <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/reverse-linked-list/description/">206. Reverse Linked List</a></p> <p>The entire operation consists of rerouting the single pointer among <code class="language-plaintext highlighter-rouge">curr</code>, <code class="language-plaintext highlighter-rouge">pred</code>, and <code class="language-plaintext highlighter-rouge">suc</code>: replacing <code class="language-plaintext highlighter-rouge">curr.next = suc</code> with <code class="language-plaintext highlighter-rouge">curr.next = pred</code>. So there is no pointer exsiting between <code class="language-plaintext highlighter-rouge">curr</code> and <code class="language-plaintext highlighter-rouge">pred</code>, otherwise there will be a cycle. - why initialize <code class="language-plaintext highlighter-rouge">pred</code> as <code class="language-plaintext highlighter-rouge">None</code> instead of <code class="language-plaintext highlighter-rouge">dummy_head (dummy_head.next = head)</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LitsNode</span><span class="p">]):</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">:</span> <span class="c1"># check
</span>            <span class="n">suc</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="c1"># adjust
</span>            <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">pred</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">curr</span> <span class="c1"># move
</span>            <span class="n">cur</span> <span class="o">=</span> <span class="n">succ</span> 
        <span class="k">return</span> <span class="n">pred</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/">24. Swap Nodes in Pairs</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">swapPairs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy_head</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dummy_head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">dummy_head</span>
        <span class="c1">#        [0,   1,   2,    3]
</span>        <span class="c1"># pred, curr, suc
</span>        <span class="k">while</span> <span class="n">pred</span><span class="p">.</span><span class="nb">next</span> <span class="ow">and</span> <span class="n">pred</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
        <span class="c1"># the length must be even
</span>            <span class="n">curr</span> <span class="o">=</span> <span class="n">pred</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">suc</span> <span class="o">=</span> <span class="n">pred</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>

            <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">suc</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">pred</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">suc</span>
            <span class="n">suc</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr</span>

            <span class="n">pred</span> <span class="o">=</span> <span class="n">curr</span>
        <span class="k">return</span> <span class="n">dummy_head</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/">19. Remove Nth Node From End of List</a></p> <p>Steps:</p> <ul> <li>These are number of loop iterations (for/while)</li> <li>To reach the n-th node in the linked list, you need <code class="language-plaintext highlighter-rouge">n - 1</code> steps (<code class="language-plaintext highlighter-rouge">n - 1</code> loop iterations)</li> </ul> <p>Elements:</p> <ul> <li>This is the count of items in a range</li> <li>For index <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>, <code class="language-plaintext highlighter-rouge">right - left</code> calculates the length (the number of elements) of interval <code class="language-plaintext highlighter-rouge">[left, right)</code></li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">next</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]):</span>
        <span class="n">dummy_head</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dummy_head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">fast</span><span class="p">,</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">dummy_head</span>
        <span class="c1"># move fast n + 1 steps to make sure there are only n nodes between fast and slow
</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>

        <span class="k">while</span> <span class="n">fast</span><span class="p">:</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">slow</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/">142. Linked List Cycle II</a></p> <p>In the cycle, <code class="language-plaintext highlighter-rouge">fast</code> pointer is chasing <code class="language-plaintext highlighter-rouge">slow</code> pointer, and the relative velocity between <code class="language-plaintext highlighter-rouge">fast</code> and <code class="language-plaintext highlighter-rouge">slow</code> pointers are <code class="language-plaintext highlighter-rouge">2 - 1 = 1</code>, so they will meet for sure</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">detectCycle</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">fast</span><span class="p">,</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">slow</span><span class="p">:</span>
                <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span>
                <span class="k">while</span> <span class="n">fast</span> <span class="o">!=</span> <span class="n">slow</span><span class="p">:</span>
                    <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>
                    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
                <span class="k">return</span> <span class="n">slow</span>
        <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Linked List]]></summary></entry><entry><title type="html">Array, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Array/" rel="alternate" type="text/html" title="Array, LeetCode"/><published>2025-06-10T00:32:13+00:00</published><updated>2025-06-10T00:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Array</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Array/"><![CDATA[<p><a href="https://leetcode.com/problems/binary-search/description/">704. Binary Search</a></p> <p>To calculate the middle index: use <code class="language-plaintext highlighter-rouge">(left + right) // 2</code>, where <code class="language-plaintext highlighter-rouge">//</code> denotes floor division. When the number of elements is even, the fomular returns the left-middle index.</p> <p>Optimization: <code class="language-plaintext highlighter-rouge">left + (right - left) // 2</code> - Avoid integer overflow caused by a too large <code class="language-plaintext highlighter-rouge">right + left</code> through interval offset</p> <p>Why O(log(n))?</p> <ul> <li>Each iteration eliminates half of elements</li> <li>Search Space shrinks exponentially <ul> <li>1st iteration: n elements</li> <li>2st iteration: n/2 elements</li> </ul> </li> <li>At most log(n) comparisons are needed <ul> <li>2^k = n, log(n) = k</li> </ul> </li> <li>Stop in advance (<code class="language-plaintext highlighter-rouge">nums[middle] == target</code>) before checking all search space (<code class="language-plaintext highlighter-rouge">left == right</code>)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]:</span> 
                <span class="c1"># target is smaller, search the left half and update the right boundary
</span>                <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]:</span> 
                <span class="c1"># target is bigger, search the right half and update the left boundary
</span>                <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">middle</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/remove-element/description/">27. Remove Element</a></p> <p>Run test cases:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
    <span class="k">assert</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># assertion error
</span></code></pre></div></div> <p>The algorithm aims to remove elements. Using <code class="language-plaintext highlighter-rouge">nums[j] == val</code> finds elements to delete, but deletion is essentially “doing nothing”. The elements that actually need operations are those where <code class="language-plaintext highlighter-rouge">nums[j] != val</code> (preserve and move postions)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeElement</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fast</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span> <span class="c1"># we need to do some operations 
</span>                <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span>
                <span class="n">slow</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">slow</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/squares-of-a-sorted-array/description/">977. Squares of a Sorted Array</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># left, right pointers:
</span><span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
    <span class="c1"># dynamic boundaries
</span>    <span class="c1"># last iteration: left == right (can terminate early)
</span></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># slow, fast pointers:
</span><span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">fast</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
    <span class="c1"># complete traversal (counldn't terminate early)
</span></code></pre></div></div> <p>In-place: algorithms that do not use additional data structures to stroe data during execution, but instead modify the original input data structure directly.</p> <p>Space Complexity:</p> <ul> <li>In-place: O(1)</li> <li>Not in-place: O(n), additional array</li> </ul> <p>Why not in-place in this question?</p> <ul> <li>Position changes are very complex (lacking a fixed direction or fixed pattern). Cross movements are difficult to accomplish with simple (two) pointer opertaions</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sortedSquares</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">left_square</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">right_square</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">left_square</span> <span class="o">&lt;=</span> <span class="n">right_square</span><span class="p">:</span> <span class="c1"># write '&lt;' first, then check whether '=' works 
</span>                <span class="n">result</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">right_square</span>
                <span class="n">position</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reslut</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_square</span>
                <span class="n">position</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/">209. Minimum Size Subarray Sum</a></p> <p>In a loop (e.g., <code class="language-plaintext highlighter-rouge">while</code>, <code class="language-plaintext highlighter-rouge">for</code>):</p> <ul> <li>record the current valid result first</li> <li>update the state <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="n">sum_of_subarray</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">:</span>
 <span class="n">min_length</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">min_length</span><span class="p">,</span> <span class="n">fast</span> <span class="o">-</span> <span class="n">slow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> 
 <span class="c1"># record min_length
</span> <span class="n">sum_of_subarray</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span> 
 <span class="c1"># update the sum_of_subarray
</span> <span class="c1"># record nums[slow] based on slow first
</span> <span class="n">slow</span> <span class="o">+=</span> <span class="mi">1</span> 
 <span class="c1"># update slow
</span> <span class="c1"># use it, and then update it
</span></code></pre></div> </div> </li> </ul> <p><code class="language-plaintext highlighter-rouge">right - left</code> actually calculates the length of the interval <code class="language-plaintext highlighter-rouge">[left, right)</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minSubArrayLen</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">min_length</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">sub_of_subarray</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fast</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">sub_of_subarray</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span>

            <span class="k">while</span> <span class="n">sub_of_subarray</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">min_length</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">min_length</span><span class="p">,</span> <span class="n">fast</span> <span class="o">-</span> <span class="n">slow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">sum_of_array</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span>
                <span class="n">slow</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">min_length</span> <span class="k">if</span> <span class="n">min_length</span> <span class="o">!=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/spiral-matrix-ii/">59. Spiral Matrix II</a></p> <p><code class="language-plaintext highlighter-rouge">for _ in range(n)</code>: iterates n times</p> <p><code class="language-plaintext highlighter-rouge">for _ in range(left, right)</code>: iterates <code class="language-plaintext highlighter-rouge">right - left</code> times -&gt; <code class="language-plaintext highlighter-rouge">[left, right)</code></p> <p><code class="language-plaintext highlighter-rouge">for _ in range(left, right, -1)</code>: iterates <code class="language-plaintext highlighter-rouge">abs(right - left)</code> times -&gt; <code class="language-plaintext highlighter-rouge">(right, left]</code></p> <p><code class="language-plaintext highlighter-rouge">n * n</code> <code class="language-plaintext highlighter-rouge">matrix</code>: every row, every column has n elements</p> <p><code class="language-plaintext highlighter-rouge">[0] * n</code>: has n elements in total</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">generateMatrix</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">top</span> <span class="o">&lt;=</span> <span class="n">bottom</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">top</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># update the boundary when all elemenets in a certain row/column is handled
</span>            <span class="k">if</span> <span class="n">top</span> <span class="o">&gt;</span> <span class="n">bottom</span><span class="p">:</span>
                <span class="k">break</span>
                
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bottom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">bottom</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">bottom</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">top</span> <span class="o">&gt;</span> <span class="n">bottom</span><span class="p">:</span>
                <span class="k">break</span>
                
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">top</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">matrix</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/count-of-range-sum/description/">327. Count of Range Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
prefix_sum
nums = [1, 2, 3]
prefix_sum = [0, 1, 3, 6]
prefix_sum[i] = nums[0] + ... nums[i - 1]
prefix_sum[j + 1] = nums[0] + ... nums[i - 1] + nums[i] + ... + nums[j]
prefix_sum[j + 1] - prefix_sum[i] = nums[i] + ... nums[j]
</span><span class="sh">"""</span>
<span class="n">prefix_sum</span> <span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
    <span class="n">prefix_sum</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">prefix_sum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num</span><span class="p">)</span>
<span class="c1"># sum of interval [i, j] could be represented as prefix_sum[j + 1] - prefix_sum[i]
</span></code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Array]]></summary></entry><entry><title type="html">Top Research Labs in Machine Learning Systems (MLSys) 🔬</title><link href="https://aabbccdkg.github.io/blog/2024/mlsys-labs-intro/" rel="alternate" type="text/html" title="Top Research Labs in Machine Learning Systems (MLSys) 🔬"/><published>2024-05-01T00:32:13+00:00</published><updated>2024-05-01T00:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2024/mlsys-labs-intro</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2024/mlsys-labs-intro/"><![CDATA[<p>This is a brief introduction to top-tier MLSys labs for Ph.D. applicants, with a primary focus on those in the United States and mainland China. If there are any omissions, please feel free to <a href="mailto:wangdong0502@gmail.com">contact me</a> to add them.</p> <h1 id="-united-states">🇺🇸 United States</h1> <h2 id="google-brain"><a href="https://research.google/">Google Brain</a></h2> <h2 id="microsoft-research-msr"><a href="https://www.microsoft.com/en-us/research/">Microsoft Research (MSR)</a></h2> <ul> <li><a href="https://www.microsoft.com/en-us/research/project/fiddle/">Fast and Efficient Infrastructure for Distributed Deep Learning (Fiddle)</a></li> </ul> <h2 id="catalyst-carnegie-mellon-university"><a href="https://catalyst.cs.cmu.edu/">Catalyst (Carnegie Mellon University)</a></h2> <ul> <li> <p><a href="https://www.cs.cmu.edu/~epxing/">Eric Xing: </a> Prof. Eric was a student of <a href="https://people.eecs.berkeley.edu/~jordan/">Prof. Michael I. Jordan</a>.</p> </li> <li> <p><a href="https://tqchen.com/">Tianqi Chen: </a></p> <ul> <li> <p><a href="https://tvm.apache.org/">TVM: </a> TVM is an open-source framework for optimizing and deploying deep learning models, with its name derived from “Tensor Virtual Machine.” Its primary goal is to optimize and compile deep learning models in an automated manner, enabling efficient execution on various hardware platforms such as CPUs, GPUs, FPGAs, and specialized AI accelerators.</p> </li> <li> <p><a href="https://xgboost.readthedocs.io/en/stable/">XGBoost: </a>XGBoost is an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework. XGBoost provides a parallel tree boosting (also known as GBDT, GBM) that solve many data science problems in a fast and accurate way. The same code runs on major distributed environment (Hadoop, SGE, MPI) and can solve problems beyond billions of examples.</p> </li> <li> <p><a href="https://github.com/apache/mxnet">MXNet: </a>Apache MXNet is a deep learning framework designed for both efficiency and flexibility. It allows you to mix symbolic and imperative programming to maximize efficiency and productivity. At its core, MXNet contains a dynamic dependency scheduler that automatically parallelizes both symbolic and imperative operations on the fly. A graph optimization layer on top of that makes symbolic execution fast and memory efficient. MXNet is portable and lightweight, scalable to many GPUs and machines.</p> </li> </ul> </li> <li> <p><a href="https://www.cs.cmu.edu/~zhihaoj2/">Zhihao Jia: </a> Prof. Zhihao Jia is a student of <a href="https://people.eecs.berkeley.edu/~matei/">Prof. Matei Zaharia (now at UC Berkeley)</a>. He seems to be more focused on system for LLM.</p> <ul> <li><a href="chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://cs.stanford.edu/~padon/taso-sosp19.pdf">TASO: </a></li> <li><a href="https://flexflow.ai/">Flexflow: </a></li> </ul> </li> </ul> <h2 id="dsail-mit"><a href="https://dsail.csail.mit.edu/">DSAIL (MIT)</a></h2> <ul> <li> <p><a href="https://hanlab.mit.edu/songhan">Song Han: </a>Pruning and Sparse related work. Prof. Song Han seems to be working on algorithm modifications and hardware, and he’s not really focused on TinyML anymore. Now he’s working on diffusion models and LLM models.</p> </li> <li> <p><a href="https://people.csail.mit.edu/kraska/">Tim Kraska: </a></p> </li> </ul> <h2 id="csail-mit"><a href="https://www.csail.mit.edu/">CSAIL (MIT)</a></h2> <ul> <li> <p><a href="https://people.csail.mit.edu/kraska/">Tim Kraska: </a> Learned Index</p> </li> <li> <p><a href="https://www.csail.mit.edu/person/saman-amarasinghe">Saman Amarasinghe: </a></p> <ul> <li><a href="chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://people.csail.mit.edu/jrk/halide-pldi13.pdf">Halide</a></li> <li><a href="https://tacos.libraries.mit.edu/">TACO</a></li> </ul> </li> </ul> <h2 id="dawn-project-stanford"><a href="https://dawn.cs.stanford.edu/">DAWN Project (Stanford)</a></h2> <ul> <li><a href="https://people.eecs.berkeley.edu/~matei/">Matei Zaharia (now at UC Berkeley): </a> Prof. Matei Zaharia (Stanford &amp; Databricks) is highly respected for building <a href="https://spark.apache.org/">Apache Spark</a> (one of the most widely used frameworks for distributed data processing, and co-started other datacenter software such as Apache Mesos and Spark Streaming) from scratch to a billion-dollar level. He serves as a PC and chair for major conferences. PipeDream, TASO, and FlexFlow is the project built by his Ph.D. student Zhihao Jia. One standout aspect of his research is that it addresses real system needs, making it impactful and practical. Not all his work prioritizes performance; for instance, one recent paper discusses offloading computation to GPUs using annotation for ease of use. Overall, pursuing a PhD under his guidance would likely lead to significant influence in the industry.</li> </ul> <h2 id="hazy-research-stanford-ai-lab"><a href="https://hazyresearch.stanford.edu/index">Hazy Research (Stanford AI Lab)</a></h2> <p>This research group focuses on MLSys and also organized a seminar series called <a href="https://mlsys.stanford.edu/">Stanford MLSys Seminar Series</a>.</p> <h2 id="riselab-university-of-california-berkeley"><a href="https://rise.cs.berkeley.edu/">RISELab (University of California, Berkeley)</a></h2> <ul> <li> <p><a href="https://people.eecs.berkeley.edu/~istoica/">Ion Stoica: </a></p> </li> <li> <p><a href="https://people.eecs.berkeley.edu/~jordan/">Michael Jordan: </a></p> </li> </ul> <p>Most recent project: <a href="https://rise.cs.berkeley.edu/projects/ray/">Ray</a></p> <p>Professors at RISE Lab have offered a course called <a href="https://ucbrise.github.io/cs294-ai-sys-fa19/">AI for Systems and Systems for AI (CS294)</a>.</p> <h2 id="system-lab-university-of-washington"><a href="https://www.cs.washington.edu/research/systems">System Lab (University of Washington)</a></h2> <ul> <li><a href="https://homes.cs.washington.edu/~luisceze/">Luis Ceze: </a> Prof. Luis Ceze focuses on Programming Language and Computer Architecture. <ul> <li><a href="https://tvm.apache.org/">TVM: </a> TVM is an open-source framework for optimizing and deploying deep learning models, with its name derived from “Tensor Virtual Machine.” Its primary goal is to optimize and compile deep learning models in an automated manner, enabling efficient execution on various hardware platforms such as CPUs, GPUs, FPGAs, and specialized AI accelerators.</li> </ul> </li> <li><a href="https://www.cs.washington.edu/people/faculty/arvind">Arvind Krishnamurthy: </a> Prof. Arvind Krishnamurthy primarily focuses on computer networks. His work involves applying networking technology to address challenges in distributed machine learning. So there is always cutting-edge support in the field of networking.</li> </ul> <h2 id="sample-university-of-washington"><a href="https://sampl.cs.washington.edu/">Sample (University of Washington)</a></h2> <h2 id="symbioticlab-university-of-michigan-ann-arbor"><a href="https://symbioticlab.org/">SymbioticLab (University of Michigan, Ann Arbor)</a></h2> <ul> <li><a href="https://www.mosharaf.com/">Mosharaf Chowdhury (the academic leader): </a> Prof. Mosharaf is a student of <a href="https://people.eecs.berkeley.edu/~istoica/">Prof. Ion Stoica</a>. He offers the course <a href="https://github.com/mosharaf/eecs598/tree/w21-ai">Systems for AI (EECS598)</a>.</li> </ul> <h2 id="system-group-new-york-university"><a href="http://www.news.cs.nyu.edu/">System Group (New York University)</a></h2> <ul> <li><a href="https://cims.nyu.edu/people/profiles/LI_Jinyang.html">Jinyang Li: </a> She is the Ph.D. advisor of <a href="https://jermainewang.github.io/">Dr. Minjie Wang</a>(the author of DGL).</li> </ul> <h2 id="shivaram-venkataraman-research-group-university-of-wisconsin-madison"><a href="https://shivaram.org/">Shivaram Venkataraman Research Group (University of Wisconsin, Madison)</a></h2> <ul> <li><a href="https://shivaram.org/">Shivaram Venkataraman: </a> Prof. Shivaram is the student of <a href="https://people.eecs.berkeley.edu/~istoica/">Prof. Ion Stoica</a>. He understands more about machine learning and less about systems. The papers he published is not too many, but the workload is substantial.</li> </ul> <h2 id="ecosystem-university-of-toronto"><a href="https://www.cs.toronto.edu/ecosystem/">EcoSystem (University of Toronto)</a></h2> <ul> <li><a href="https://www.cs.toronto.edu/~pekhimenko/">Gennady Pekhimenko: </a></li> </ul> <h1 id="-china">🇨🇳 China</h1> <p>In mainland China, it seems that most of the work in MLSys is being done in companies. However, some strong teams in distributed systems often also work on MLSys to some extent, such as <a href="https://ipads.se.sjtu.edu.cn/zh/index.html">IPADS (Shanghai Jiaotong Univeristy)</a>.</p> <h2 id="microsoft-research-labasia"><a href="https://www.microsoft.com/en-us/research/group/systems-and-networking-research-group-asia/">Microsoft Research Lab(Asia)</a></h2> <h2 id="pacman-grouptsinghua"><a href="https://pacman.cs.tsinghua.edu.cn/">PACMAN Group(Tsinghua)</a></h2> <p>More related to Arch</p> <h2 id="center-for-energy-efficient-computing-and-applicationspeking-university"><a href="https://ceca.pku.edu.cn/people/index.htm">Center for Energy-efficient Computing and Applications(Peking University)</a></h2> <p>More related to Arch</p> <h2 id="cheng-lis-research-group-univeristy-of-science-and-technology-china"><a href="http://staff.ustc.edu.cn/~chengli7">Cheng LI’s Research Group (Univeristy of Science and Technology China)</a></h2> <h2 id="ipadsshanghai-jiaotong-univeristy"><a href="https://ipads.se.sjtu.edu.cn/zh/index.html">IPADS(Shanghai Jiaotong Univeristy)</a></h2> <p>The best System Lab in Mainland China, and now is also working on some MLSys projects.</p> <h1 id="-appendix">🌟 Appendix</h1> <h2 id="some-people-worth-following-on-zhihu">Some people worth following on Zhihu</h2> <ul> <li> <p><a href="https://www.zhihu.com/people/crowowrk">Tianqi Chen: </a> Dr. Tianqi Chen is currently an Assistant Professor at Carnegie Mellon University. He helps run the <a href="https://catalyst.cs.cmu.edu/">Catalyst Group</a>.</p> </li> <li> <p><a href="https://www.zhihu.com/people/zhanghuaizheng">Huaizheng Zhang: </a> Dr. Huaizheng Zhang’s <a href="https://github.com/HuaizhengZhang/AI-System-School">AI-System-School</a> is an open project aimed at collecting and organizing research papers, tools, and resources related to MLSys, Large Language Models (LLM), and Generative AI (GenAI). It provides researchers and engineers with a systematic learning path and practical guide to help them better understand and apply these cutting-edge technologies. Here is his <a href="https://huaizheng.xyz/">personal website</a>.</p> </li> <li> <p><a href="https://www.zhihu.com/people/breaknever">Yue Zhao: </a> Dr. Yue Zhang is currently an Assistant Professor at the University of Southern California. He was also a student of Prof. Zhihao Jia. Here is his <a href="https://github.com/yzhao062">personal website</a>.</p> </li> </ul>]]></content><author><name></name></author><category term="MLSys-Learning-Journal"/><category term="MLSys-Learning-Journal"/><summary type="html"><![CDATA[A brief introduction to top-tier MLSys labs for Ph.D. applicants.]]></summary></entry></feed>