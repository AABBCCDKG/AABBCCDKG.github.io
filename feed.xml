<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://aabbccdkg.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://aabbccdkg.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-03T18:36:34+00:00</updated><id>https://aabbccdkg.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">CS252 Final</title><link href="https://aabbccdkg.github.io/blog/2025/CS252Final/" rel="alternate" type="text/html" title="CS252 Final"/><published>2025-08-03T15:32:13+00:00</published><updated>2025-08-03T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/CS252Final</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/CS252Final/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">A | B</code>: <code class="language-plaintext highlighter-rouge">A</code>的输出是<code class="language-plaintext highlighter-rouge">B</code>的输入，比如<code class="language-plaintext highlighter-rouge">cat infile.txt | grep hello</code></p> <ul> <li>在<code class="language-plaintext highlighter-rouge">C</code>程序中，模拟<code class="language-plaintext highlighter-rouge">bash</code>的重定向和管道等行为，一定会用到<code class="language-plaintext highlighter-rouge">fork()</code> + <code class="language-plaintext highlighter-rouge">dup2()</code> + <code class="language-plaintext highlighter-rouge">pipe()</code> <ul> <li><code class="language-plaintext highlighter-rouge">A | B</code> <ul> <li><code class="language-plaintext highlighter-rouge">pipe()</code>创建一个管道</li> <li><code class="language-plaintext highlighter-rouge">fork()</code>创建两个子进程(执行A和B)</li> <li><code class="language-plaintext highlighter-rouge">dup2()</code>把<code class="language-plaintext highlighter-rouge">A</code>的<code class="language-plaintext highlighter-rouge">stdout</code>-&gt;管道写端, <code class="language-plaintext highlighter-rouge">B</code>的<code class="language-plaintext highlighter-rouge">stdin</code>&lt;-管道读端</li> <li><code class="language-plaintext highlighter-rouge">exec()</code>分别执行<code class="language-plaintext highlighter-rouge">A</code>和<code class="language-plaintext highlighter-rouge">B</code>命令, 一般是<code class="language-plaintext highlighter-rouge">execvp(命令, 参数)</code>, <code class="language-plaintext highlighter-rouge">execlp()</code>等</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">&lt; file</code> <ul> <li><code class="language-plaintext highlighter-rouge">open(file, O_RDONLY)</code>打开文件</li> <li><code class="language-plaintext highlighter-rouge">dup2(fd, STDIN_FILENO)</code>把文件重新定向为标准输入(通常放在fork后的子进程中)</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">&gt; file</code> <ul> <li><code class="language-plaintext highlighter-rouge">open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644)</code>打开文件</li> <li><code class="language-plaintext highlighter-rouge">dup2(fd, STDOUT_FILENO)</code>把文件重新定向为标准输出</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">&gt;&gt; file</code> <ul> <li><code class="language-plaintext highlighter-rouge">open(file, O_WRONLY | O_CREAT | O_APPEND, 0644)</code>打开文件</li> <li><code class="language-plaintext highlighter-rouge">dup2(fd, STDOUT_FILENO)</code>把文件重新定向为标准输出 ```C //A, B是命令, argvA/argvB是参数组 void redirect(const char * A, char *const argvA[], const char * B, char *const argvB[]) { // A | B int fd[2]; if(pipe(fd) == -1){ perror(“pipe”); exit(1); };</li> </ul> </li> </ul> <p>int pid1 = fork(); if (pid1 == -1) { perror(“fork1”); exit(1); } if (pid1 == 0) { // handle A close(fd[0]); dup2(fd[1], 1); //STDOUT这个宏不存在，用1代替 close(fd[1]); //重新定向后就可以关闭 execvp(A, argvA); //一般后面直接加perror perror(“exec A”); exit(1); }</p> <p>int pid2 = fork(); if (pid2 == -1) { perror(“fork2”); exit(1); } if (pid2 == 0){ // handle B close(fd[1]); dup2(fd[0], 0); //STDIN这个宏也不存在，用0代替 close(fd[0]); //重新定向后就可以关闭 execvp(B, argvB); perror(“exec B”); exit(1); }</p> <p>//在父进程中，关闭所有pip端并等待两个子进程 close(fd[0]); //不关闭读端，写端就会一直挂着 close(fd[1]); waitpid(pid1, NULL, 0); waitpid(pid2, NULL, 0); } ```</p> </li> </ul> <pre><code class="language-C">// &lt; file
void redirectToFile(const char * file) {
    int fd = open(file, O_RDONLY); // 不需要管道，所以不是int fd[2], 只要用open(file, O_RDONLY)就可以
    if (fd == -1) {
        perror("file open failed");
        exit(1);
    }
    if (dup2(fd, STDIN_FILENO) == -1) {
        perror("dup2 failed");
        exit(1);
    }
    close(fd); //最后依然是关闭
}
</code></pre> <pre><code class="language-C">// &gt; file
void redirect(const char * file) {
    int fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("open failed");
        exit(1);
    }
    if (dup2(fd, STDOUT_FILENO) == -1) {
        perror("dup2 failed");
        exit(1);
    }
    close(fd);
}
</code></pre> <pre><code class="language-C">// &gt;&gt; file
void redirect(const char * file) {
    int fd = open(file, O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (fd == -1) {
        perror("open failed");
        exit(1);
    } 
    if (dup2(fd, STDOUT_FILENO) == -1) {
        perror("dup2 failed");
        exit(1);
    }
    close(fd);
}
</code></pre> <p><code class="language-plaintext highlighter-rouge">sort &lt; file.txt</code>: 读取<code class="language-plaintext highlighter-rouge">file.txt</code>的内容并进行排序，等价于<code class="language-plaintext highlighter-rouge">cat file.txt | sort</code></p> <ul> <li><code class="language-plaintext highlighter-rouge">sort</code>从<code class="language-plaintext highlighter-rouge">stdin</code>读取指令: <pre><code class="language-C">char *argv[] = {"sort", NULL};
execvp("sort", argv);
</code></pre> </li> <li><code class="language-plaintext highlighter-rouge">sort</code>从<code class="language-plaintext highlighter-rouge">file.txt</code>读取指令: <pre><code class="language-C">char *argv[] = {"sort", "file.txt", NULL};
execvp("sort", argv);
</code></pre> </li> <li><code class="language-plaintext highlighter-rouge">grep</code>从<code class="language-plaintext highlighter-rouge">stdin</code>读取指令: <pre><code class="language-C">char *argv[] = {"grep", "hello", NULL};
execvp("grep", argv);
</code></pre> </li> <li><code class="language-plaintext highlighter-rouge">grep</code>从<code class="language-plaintext highlighter-rouge">file.txt</code>读取指令: <pre><code class="language-C">char *argv[] = {"grep", "hello", "file.txt", NULL};
execvp("grep", argv);
</code></pre> </li> </ul> <pre><code class="language-C">//sort &lt; file.txt
void sortCommand(const char * file) {
    int fd = open(file, O_RDONLY);
    if (fd == -1) {
        perror("open file failed");
        exit(1);
    }
    if(dup2(fd, STDIN_FILENO) == -1){
        perror("dup2 failed");
        exit(1);
    }
    close(fd);

    char *argv[] = {"sort", NULL};
    execvp('sort', argv);
    perror("sort error");
    exit(1);
}
</code></pre> <p><code class="language-plaintext highlighter-rouge">grep A</code>: 从标准输入读取内容，并筛出包含<code class="language-plaintext highlighter-rouge">A</code>的行</p> <pre><code class="language-C">void grep(char * A){
    char * argv[] = {"grep", A, NULL};
    execvp("grep", argv);
    perror("exec fail");
    exit(1);
}
</code></pre> <p><code class="language-plaintext highlighter-rouge">command &gt;&gt; file.txt</code>: 追加重定向，把<code class="language-plaintext highlighter-rouge">command</code>输出追加到<code class="language-plaintext highlighter-rouge">file.txt</code>的结尾(不会覆盖原本的内容)</p> <pre><code class="language-C">void redirect(const char* command, const char* file){
    int fd = open(file, O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (fd == -1) {
        perror("open fail");
        exit(1);
    }
    if (dup2(fd, STDOUT_FILENO) == -1){
        perror("dup2 failed");
        exit(1);
    }
    close(fd);//不要忘记close
    char *argv[] = {(char *) command, NULL}; //不要写死，用command变量
    execvp(command, argv);
    perror("exec failed");
    exit(1);
}
</code></pre> <p><code class="language-plaintext highlighter-rouge">sort &lt; infile.txt | grep hello &gt;&gt; output.txt</code>: 读取<code class="language-plaintext highlighter-rouge">file.txt</code>的内容并排序，从中找到包含<code class="language-plaintext highlighter-rouge">hello</code>的行，添加到<code class="language-plaintext highlighter-rouge">output.txt</code>的结尾</p> <ul> <li>sort: <ul> <li>读取从STDIN 变成infile.txt</li> <li>输出从STDOUT变成pipeline写端</li> </ul> </li> <li>grep: <ul> <li>读取从STDIN变成pipeline读端</li> <li> <p>输出从STDOUT变成output.txt ```C //grepsort arg1 arg2 arg3 = sort &lt; arg2 | grep arg1 » arg3 //参数应该是, argv[0] = grepsort, argv[1] = arg1 void grepsort(char * argv[]){ int fd[2]; //一个管道即可,因为只有一个管道符号 | if (pipe(fd) == -1){ perror(“pipe failed”); exit(1); } int pid1 = fork(); //不要忘记检查fork if (pid1 == -1) { perror(“fork1 failed”); exit(1); } //fork成功，还有父子进程之分 if (pid1 == 0){ close(fd[0]); //子进程1: sort &lt; infile.txt | -&gt; 写入管道 int fd_in = open(argv[2], O_RDONLY); if (fd_in == -1){ perror(“open infile failed”); exit(1); } //这里的输入来自infile.txt, 输出是去管道，所以有两个dup2 if(dup2(fd_in, STDIN_FILENO) == -1){ // dup2(A, STDIN_FILENO): 标准输入来自A perror(“dup2 from infile.txt failed”); exit(1); } if(dup2(fd[1], STDOUT_FILENO) == -1){ //标准输出来自fd[1] perror(“dup2 to pipe failed”); exit(1); } close(fd_in); close(fd[1]);</p> <p>char * argv1[] = {“sort”, NULL}; execvp(“sort”, argv1); perror(“sort exec failed”); exit(1); }</p> </li> </ul> <p>int pid2 = fork(); if (pid2 == -1) { perror(“fork2 failed”); exit(1); } if (pid2 == 0) { close(fd[1]); int fd_out = open(argv[3], O_WRONLY | O_CREAT | O_APPEND, 0644); if (fd_out == -1) { perror(“open output failed”); exit(1); } if(dup2(fd_out, STDOUT_FILENO) == -1){ perror(“dup2 for writing failed”); exit(1); } if (dup2(fd[0], STDIN_FILENO) == -1){ perror(“dup2 for pipe reading failed”); exit(1); } close(fd_out); close(fd[0]);</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  char * argv2[] = {"grep", argv[1], NULL};
  execvp("grep", argv2);
  perror("grep exec failed");
  exit(1);   }   close(fd[0]);   close(fd[1]);   wait(pid1, NULL, 0);   wait(pid2, NULL, 0); }
</code></pre></div> </div> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`print entries`就是打印每一行的意思 `entries = lines`

`sort &lt; infile.txt | grep hello &gt;&gt; output.txt`这本身就是一个`bash`命令，所以如果要用`program`来实现它，一定不是用`bash`，而是用`C`.

```C
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Backtracking]]></summary></entry><entry><title type="html">Backtracking, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Backtracking/" rel="alternate" type="text/html" title="Backtracking, LeetCode"/><published>2025-07-19T15:32:13+00:00</published><updated>2025-07-19T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Backtracking</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Backtracking/"><![CDATA[]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Backtracking]]></summary></entry><entry><title type="html">CS252 Mid</title><link href="https://aabbccdkg.github.io/blog/2025/CS252Mid/" rel="alternate" type="text/html" title="CS252 Mid"/><published>2025-07-19T15:32:13+00:00</published><updated>2025-07-19T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/CS252Mid</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/CS252Mid/"><![CDATA[<p>Premature Free: 过早释放内存</p> <pre><code class="language-C++">int *p = malloc(sizeof(int));
*p = 6; //将分配到内存中的值设置为6, p指针的值是*p = 6
free(p); //释放内存后，p虽然依然指向那块地址，但内存属于操作系统管理，p成为了一个悬空指针(dangling pointer)，不是free(*p)，因为p是指存储的地址，*p是p存储的地址里保存的值
printf("%d\n", *p);
</code></pre> <p>Double Free</p> <pre><code class="language-C++">int *p = malloc(sizeof(int));
*p = 6;
free(p);
//free(p)后，p是dangling pointer,为了防止滥用，通常要加上p = NULL，手动清空指针
free(p);
</code></pre> <p>Wild Free</p> <pre><code class="language-C++">int *p = malloc(sizeof(int));
*p = 6;
free(&amp;p); // 释放了栈上的地址(指针本身的地址)，应该是free(p)
</code></pre> <pre><code class="language-C++">int *p = malloc(sizeof(int));
*p = 6;
p = p + 1
free(p); //释放的并不是原始malloc返回的地址
</code></pre> <p>Memory Smashing (Heap Buffer Overflow)</p> <pre><code class="language-C++">int *g = malloc(20 * sizeof(int)); //将指针看成一个数组，length = 20
g[20] = 40; //index &lt;= 19
free(g);
</code></pre> <p>Memory Leak:</p> <pre><code class="language-C++">int g = new int;
// new和malloc差不多，&amp;g是指针本身的地址，g是存储值的地址，*g是值
//malloc靠free(g)来释放内存，new靠delete g来释放内存
*g = 40;
int g = new int;
*g = 41;
delete g;
</code></pre> <pre><code class="language-C++">int *g = malloc(sizeof(int));
*g = 6;
g = NULL;//原来存储6的地址丢失，永远无法有效free(g)
</code></pre> <p>CPU-bound process是那种几乎需要一直使用CPU的进程，如果时间片(quantum)太短，会让其运行变慢。比如:</p> <ul> <li>CPU-bound 任务需要 100ms 才能完成，如果时间片是 100ms，一次就完成；如果时间片是 10ms，它需要被调度 10 次，每次都上下文切换；总耗时更长；进程调度效率更低 - 因此，quantum越短，context switch overhead越少</li> </ul> <p>Multilevel Feedback Queue (MLFQ): 一种基于优先级的调度策略，低优先级队列中的进程容易一直被高优先级进程抢占，如果不加处理，这些低优先级进程可能永远得不到 CPU 时间，即发生饥饿(starvation)</p> <ul> <li>奖励交互型进程(short quantum) -&gt; 提高优先级</li> <li>惩罚CPU密集型进程(长时间运行) -&gt; 降低优先级</li> <li>长时间低优先级，会增加其优先级</li> </ul> <p>State: <code class="language-plaintext highlighter-rouge">New -&gt; Ready -&gt; Running -&gt; Exit</code> Or <code class="language-plaintext highlighter-rouge">New -&gt; Ready -&gt; Running -&gt; Waiting -&gt; Ready</code> (大多数在waiting state)(处于Ready状态的进程不会直接进入waiting)</p> <p>waiting: 运行中的进程遇到阻塞事件(I/O device operations)</p> <p>处于运行状态的进程数量，最多等于CPU核心数(number of cores,有时候cores也称为processors)</p> <p>In the malloc implement, we have a global variable <code class="language-plaintext highlighter-rouge">header * lastFencepost</code>, what is the use for this variable.</p> <p>global: 多个函数共享lastFencepost这个信息（allocate_object, coalesce）</p> <p>检查sbrk()的新内存是否是连续: lastFencepost + sizeof(fencepost) = the_start_of_new_chunk</p> <ul> <li>如果是连续，合并，合并过程中间的栅栏块会变成空闲内存的一部分，更新lastFencepost为新区域的最右端。</li> <li>如果不是，更新lastFencepost为新区域最右端</li> </ul> <pre><code class="language-C++">int obj_can_be_expanded(size_t new_size, int *oldptr){
   //返回0就是可以，返回1就是不行之类的，返回类型可以用int来代替bool
   //ptr是指针，指向data开始的地方，所以是*ptr, 类型应该是整数指针 
    header *h = (header*)((char*)oldptr - ALLOCATE_HEADER_SIZE);//知道指向data的ptr，如何找h
    header *rightheader = (header*)((char*)h + get_size(h));
    size_t available = get_size(h) + get_size(rightheader) - ALLOCATE_HEDAER_SIZE;
    if(get_state(rightheader) == UNALLOCATED &amp;&amp; available &gt;= new_size) {
        return 0; //可以扩展
    }
    return 1;
}
</code></pre> <pre><code class="language-C++">int heap_free_count(size_t minSize, size_t maxSize) {
    int count = 0;
    for (i = 0; i &lt; N_LIST; i++) {
        header *freelist = &amp;freelistSentinels[i]
        header *cur = freelist-&gt;next;
        while (cur != freelist) {
            size_t t = get_size(curr)
            if (size_t &gt;= minSize &amp;&amp; size_t &lt;= maxSize){
                count++;
            }
            cur = cur-&gt;next;
        }
    }
    return count;
}
</code></pre> <pre><code class="language-C++">int pipe_open(char * command) {
    int fd[2]; //定义一个长度为2的整数组，用于表示一个管道的两个端点，fd[0]是读端，fd[1]是写端
    res = pipe(fd); //创建一个无名管道成功为0
    if (res != 0) {
        perror('pipe failed');
        exit(1); //异常而退出
    }
    pid_t pid = fork(); // 0 是子进程
    if (pid == 0) {
        close(fd[0]);
        dup2(fd[1], 1);//标准输出指向写端
        char ** args = parseCmd(command);//两个星表示字符串
        execvp(args[0], args);
        // only something wrong
        perror('execvp');
        exit(1);
    } else{
        close(fd[1]);//otherwise, it will hang
        return fd[0]
    }
}

char ** parseCmd(char * command) {
    int nargs = 0;
    char ** args = malloc((strlen(command) + 1) * sizeof(char*));
    char *s = strup(command);
    char *p = s;
    while (*p != '\0'){
        while (*p == ''){
            p++;
        }
        if (*p != '\0') {
            args[nargs] = p;
            nargs++;
            while (*p != '\0' and *p != ' '){
                p++;
            }
            if (*p == '\0'){
                break
            }
            if (*p = ' '){
                *p = '\0';//命令行中的end of word是'\0';
                p++;
            }
        }
        args[nargs] = NULL;
    }
    return args;
}
</code></pre>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Backtracking]]></summary></entry><entry><title type="html">Mock Interview(2), LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Mock-Interview(2).md/" rel="alternate" type="text/html" title="Mock Interview(2), LeetCode"/><published>2025-07-18T18:32:13+00:00</published><updated>2025-07-18T18:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Mock-Interview(2).md</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Mock-Interview(2).md/"><![CDATA[<p><a href="https://leetcode.com/problems/minimum-window-substring/description/">76. Minimum Window Substring</a></p> <p>Key Feature:</p> <ul> <li>The core challenge is to match character frequencies exactly - not just whether the character appears, but whether it appears the correct number of times as specified by <code class="language-plaintext highlighter-rouge">t</code></li> </ul> <p>Core Solution Strategy:</p> <ul> <li>An additional hashmap <code class="language-plaintext highlighter-rouge">window_counts</code> <ul> <li>Tracks the frequency of each character in the current window</li> <li>Used to compare againt the target frequency map <code class="language-plaintext highlighter-rouge">dict_t</code></li> </ul> </li> <li>An extra variable <code class="language-plaintext highlighter-rouge">formed</code> <ul> <li>Keeps count of how many characters in the current window have their frequency exactly equal to what <code class="language-plaintext highlighter-rouge">t</code> requires</li> <li>When <code class="language-plaintext highlighter-rouge">formed == required</code> (where <code class="language-plaintext highlighter-rouge">required = len(dict_t)</code>), it means that the window is valid</li> </ul> </li> </ul> <p>Part 1: Count the Frequency of characters in <code class="language-plaintext highlighter-rouge">t</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Firts way
</span><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="n">dict_t</span> <span class="o">=</span> <span class="nc">Count</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1"># C is capitalized
</span>
<span class="c1"># Second way
</span><span class="n">dict_t</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
    <span class="n">dict_t</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_t</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> 
    <span class="c1"># dict_t.get(char): get the value of dict_t[char]
</span>    <span class="c1"># dict_t.get(char, 0): get the value of dict_t[char], if there is no char in dict_t, return 0
</span></code></pre></div></div> <p>Part 2: Find a Window in <code class="language-plaintext highlighter-rouge">s</code> that contains those characters with required frequencies</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># general step:
</span><span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># window sliding is a double pointer problem
</span><span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">():</span>
    <span class="c1"># in what condition, we should shrink the window(move the left pointer to the right, most of time, it would be while loop)
</span></code></pre></div></div> <p>Formed: Whenever the frequency of a character in the current window exactly macthes the required count in <code class="language-plaintext highlighter-rouge">t</code>, do addition</p> <p>Required: the number of different type of character in <code class="language-plaintext highlighter-rouge">t</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minWindow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">dict_t</span> <span class="o">=</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">min_length</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">required</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">dict_t</span><span class="p">)</span>
        <span class="n">window_count</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">formed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_left</span> <span class="o">=</span><span class="mi">0</span>
        <span class="n">min_right</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">char</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="n">window_count</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">window_count</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">dict_t</span> <span class="ow">and</span> <span class="n">window_count</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">==</span> <span class="n">dict_t</span><span class="p">[</span><span class="n">char</span><span class="p">]:</span>
                <span class="n">formed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">formed</span> <span class="o">==</span> <span class="n">required</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">min_length</span><span class="p">:</span>
                    <span class="n">min_length</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">min_length</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">min_left</span> <span class="o">=</span> <span class="n">left</span>
                    <span class="n">min_right</span> <span class="o">=</span> <span class="n">right</span>
                <span class="n">window_count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="ow">in</span> <span class="n">dict_t</span> <span class="ow">and</span> <span class="n">window_count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">dict_t</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]:</span>
                    <span class="n">formed</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="sh">""</span> <span class="k">if</span> <span class="n">min_length</span> <span class="o">==</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span> <span class="k">else</span> <span class="n">s</span><span class="p">[</span><span class="n">min_left</span><span class="p">:</span> <span class="n">min_right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># min_length == float('inf') means throughout the entire traversal, no valid window that satisfies the condition was ever found,
</span>        <span class="c1">#  so min_length was never updated: no need to do the check: if len(s) &lt; len(t)
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">3. Longest Substring Without Repeating Characters</a></p> <p>Window means there are two pointers: <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code></p> <p><code class="language-plaintext highlighter-rouge">set()</code> is unordered, but it allows <code class="language-plaintext highlighter-rouge">O(1)</code> time complexity for checking the existence of an element.</p> <p>For sliding window problems, the typical patter is:</p> <ul> <li>At each step, expand the window by moving the right pointer, and then shrink the window from the left as needed to maintain the desired condition (window sliding is a double pointer problem)</li> </ul> <p>The <code class="language-plaintext highlighter-rouge">set</code> object does not support <code class="language-plaintext highlighter-rouge">.append()</code> - use <code class="language-plaintext highlighter-rouge">.add()</code> to insert elements and <code class="language-plaintext highlighter-rouge">.remove()</code> to delete them</p> <p>When shrinking the window, it’s often not enough to remove a single element. You should use a <code class="language-plaintext highlighter-rouge">while</code> loop to continue shrinking the window from the left until the condition is satisfied again.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">char_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">while</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="ow">in</span> <span class="n">char_set</span><span class="p">:</span>
                <span class="n">char_set</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">])</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">char_set</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>
            <span class="n">max_length</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_length</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">max_length</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems discussed during a mock interview on 2025-07-18]]></summary></entry><entry><title type="html">Binary Tree, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Tree/" rel="alternate" type="text/html" title="Binary Tree, LeetCode"/><published>2025-06-15T15:32:13+00:00</published><updated>2025-06-15T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Tree</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Tree/"><![CDATA[<p>Full Binary Tree (Proper Binary Tree)</p> <ul> <li>every node has either exactly two children or no children.</li> </ul> <p>Perfect Binary Tree (Strictly Full Binary Tree):</p> <ul> <li>Every internal node has two children</li> <li>All leaf nodes appear at the same depth(level).</li> <li>Level (k) start from 0 <ul> <li>Every level has <code class="language-plaintext highlighter-rouge">2^k</code> nodes (Level(k) start from 0).</li> <li>Total nodes: <code class="language-plaintext highlighter-rouge">2^(k+1) - 1</code>.</li> </ul> </li> <li>Level (k) start from 1 <ul> <li>Every level has <code class="language-plaintext highlighter-rouge">2^(k - 1)</code>. nodes (Level(k) start from 0)</li> <li>Total nodes: <code class="language-plaintext highlighter-rouge">2^(k) - 1</code>.</li> </ul> </li> </ul> <p>Complete Binary Tree:</p> <ul> <li>Every level, except possibly the last, is completely filled.</li> <li>In the last level, all nodes are as far left as possible, with no “gaps” between them.</li> <li>heap is a complete binary tree.</li> </ul> <p>Binary Search Tree:</p> <ul> <li>Average case for search and insert: O(log n) when the tree is approximately balanced (each comparison eliminates about half of the remaining nodes).</li> <li>Worst case for search and insert: O(n) if the tree becomes completely unbalanced (degenerates into a chain).</li> <li>Left -&gt; Small, Top -&gt; Medium, Right -&gt; Big</li> <li>No requirement for node structure</li> </ul> <p>Balanced Binary Search Tree:</p> <ul> <li>∀ N: height(N.left) – height(N.right) ≤ 1</li> <li>the basic of map and set (the key in map and the element in set is in order)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Initialization by Linked List:
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="c1"># Initialization by List:
</span><span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">curr</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> 
<span class="n">left_children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">right_children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div> <p>Using backtracking to build binary tree</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">list_to_complete_binary_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nf">list_to_complete_binary_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nf">list_to_complete_binary_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div> <p>DFS:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># result should be the input of dfs, so that every recursive call will write into the same list
# pre-order
</span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="c1"># middle
</span>    <span class="n">left_branch</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># left
</span>    <span class="n">right_branch</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1"># right
</span>    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p>BFS</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span> <span class="c1"># queue stores node instead of the value of node
</span>    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">length_of_level</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length_of_level</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">144. Binary Tree Preorder Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1: _dfs accept result as input
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> 
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># stop iteration
</span>        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">left_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="c1"># 2. _dfs doesn't accept result as input
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span> <span class="c1"># return value
</span>        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># return the value of left_branch
</span>        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="c1"># left and right are all list 
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/">145. Binary Tree Postorder Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__ini__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
    
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__ini__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
    
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>
<span class="c1"># Or
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="p">[]</span> <span class="c1"># in case _dfs only run the first two line code
</span>    
    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">left_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">94. Binary Tree Inorder Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">left_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">right_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
<span class="c1"># Or
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/">102. Binary Tree Level Order Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
    
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">length_of_level</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length_of_level</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/invert-binary-tree/description/">226. Invert Binary Tree</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span> <span class="c1"># Al
</span>        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span> 
            <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            <span class="c1"># Using parallel assignment in python 
</span>            <span class="c1"># temp = node.left
</span>            <span class="c1"># node.left = node.right
</span>            <span class="c1"># node.right = temp
</span>            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/symmetric-tree/description/">101. Symmetric Tree</a></p> <p><code class="language-plaintext highlighter-rouge">len(nums)</code> is even:</p> <ul> <li><code class="language-plaintext highlighter-rouge">len(nums) // 2</code> returns the left middle index.</li> <li><code class="language-plaintext highlighter-rouge">math.ceil(nums / 2)</code> returns the right middle index.</li> </ul> <p><code class="language-plaintext highlighter-rouge">len(nums)</code> is odd:</p> <ul> <li>both return the middle one</li> </ul> <p>queue could also store a tuple <code class="language-plaintext highlighter-rouge">(node.left, node.right)</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">right</span> <span class="ow">or</span> <span class="n">left</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">left</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">.</span><span class="n">right</span><span class="p">))</span> 
            <span class="c1"># compare whether the whole tree is symmetric
</span>            <span class="c1"># queue.append((left.left, left.right)): compare the left branch of left is symmetric or not
</span>            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">right</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">right</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">104. Maximum Depth of Binary Tree</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span> 
            <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">depth</span>
        <span class="c1"># In most problems, it doesn't matter whether 
</span>        <span class="c1"># you place operations like +1, updates, 
</span>        <span class="c1"># or returns at the beginning or end of a loop. 
</span>        <span class="c1"># Confused about the initial value of depth? move the position (beginning is more reasonable)
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/">111. Minimum Depth of Binary Tree</a></p> <p><code class="language-plaintext highlighter-rouge">leaf node</code>: both <code class="language-plaintext highlighter-rouge">node.left</code> and <code class="language-plaintext highlighter-rouge">node.right</code> are <code class="language-plaintext highlighter-rouge">None</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">depth</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/count-complete-tree-nodes/description/">222. Count Complete Tree Nodes</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">getDepth</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="n">depth_of_left_branch</span> <span class="o">=</span> <span class="nf">getDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># getDepth is the method in countNodes, no need for self when using getDepth in countNodes
</span>        <span class="n">depth_of_right_branch</span> <span class="o">=</span> <span class="nf">getDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">depth_of_left_branch</span> <span class="o">==</span> <span class="n">depth_of_right_branch</span><span class="p">:</span>
            <span class="c1"># the left branch is full
</span>            <span class="k">return</span> <span class="mi">2</span><span class="o">^</span><span class="n">depth_of_left_branch</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> 
            <span class="c1"># + 1 is counting node itself
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the right branch is full
</span>            <span class="k">return</span> <span class="mi">2</span><span class="o">^</span><span class="n">depth_of_right_branch</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">counNodes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/balanced-binary-tree/description/">110. Balanced Binary Tree</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Some changes based on getDepth
        def getDepth(node):
            if not node:
                return 0
            left = getDepth(node.left)
            # could be filled for the operations on left branch
            right = getDepth(node.right)
            # could be filled for the operations on right branch

            # could be filled for the operation on current node
            return max(left, right) + 1
        </span><span class="sh">"""</span>
        <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            
            <span class="n">left</span> <span class="o">=</span> <span class="nf">check</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">right</span> <span class="o">=</span> <span class="nf">check</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">right</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

            <span class="k">if</span> <span class="nf">abs</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nf">check</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-paths/description/">257. Binary Tree Paths</a></p> <p><code class="language-plaintext highlighter-rouge">Process currnt node</code></p> <ul> <li>update the state <ul> <li>Add the node’s information into global state or the state passed as a parameter. <ul> <li>path problem: state.path.append(node.val)</li> <li>sum problems: state.sum += node.val</li> <li>min/max problems: state.best = max(state.best, node.val)</li> <li>graph visits: state.visited.add(node)</li> </ul> </li> </ul> </li> <li>Check or Record the result <ul> <li>If the current state meets your goal, then save to your results list and optionally return/prune. <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
  <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
  <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
  <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
  <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
          <span class="k">return</span>
      <span class="c1"># ending condition:information to global state
</span>      <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
          <span class="n">paths</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
          <span class="k">return</span>

      <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
          <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="sh">'</span><span class="s">-&gt;</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
            
      <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
          <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="sh">'</span><span class="s">-&gt;</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
      <span class="nf">_dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nf">str</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">paths</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <p><a href="https://leetcode.com/problems/sum-of-left-leaves/description/">404. Sum of Left Leaves</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">_sum</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> 
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="c1"># No matter whether node itself has a right child or not, it does not affect whether node.left is a leaf node.
</span>                <span class="n">_sum</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span>
            <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="nf">_dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_sum</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/">513. Find Bottom Left Tree Value</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Tree]]></summary></entry><entry><title type="html">NVIDIA, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Nvidia/" rel="alternate" type="text/html" title="NVIDIA, LeetCode"/><published>2025-06-14T16:32:13+00:00</published><updated>2025-06-14T16:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Nvidia</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Nvidia/"><![CDATA[<p><a href="https://leetcode.com/problems/product-of-array-except-self/description/?envType=company&amp;envId=nvidia&amp;favoriteSlug=nvidia-three-months">238. Product of Array Except Self</a></p> <p>When there are no elements to multiple at a certain position, the product should be initialized as <code class="language-plaintext highlighter-rouge">1</code>, since <code class="language-plaintext highlighter-rouge">1</code> is the identity element for multiplication and does not affect the overall result. That is the reason why <code class="language-plaintext highlighter-rouge">left_prod</code> and <code class="language-plaintext highlighter-rouge">right_prod</code> are both initialized as <code class="language-plaintext highlighter-rouge">1</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">productExceptSelf</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">left_prod</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">right_prod</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="c1"># append the left_prod first, update the left_prod with current element second to except self
</span>            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left_prod</span><span class="p">)</span>
            <span class="n">left_prod</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">right_prod</span>
            <span class="n">right_prod</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/group-anagrams/description/?envType=company&amp;envId=nvidia&amp;favoriteSlug=nvidia-three-months">49. Group Anagrams</a></p> <p>When you’re comparing elements in a list pairwise, <code class="language-plaintext highlighter-rouge">hashmap</code> could reduce the time complexity from <code class="language-plaintext highlighter-rouge">O(n^2)</code> to <code class="language-plaintext highlighter-rouge">O(n)</code> using a key with distinguishing or grouping capability.</p> <p><code class="language-plaintext highlighter-rouge">Anagram: same after sorting</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">groupAnagrams</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="c1"># sorted(word) will return a list
</span>            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">]</span>
        <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">hashmap</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span> 
        <span class="c1"># list(hashmap.keys())
</span>        <span class="c1"># list(hashmap.values()) 
</span>        <span class="c1"># list(hashmap.items()) List[tuple]
</span></code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems frequently asked by NVIDIA]]></summary></entry><entry><title type="html">Stack and Queue, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Stack-and-Queue/" rel="alternate" type="text/html" title="Stack and Queue, LeetCode"/><published>2025-06-14T15:32:13+00:00</published><updated>2025-06-14T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Stack-and-Queue</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Stack-and-Queue/"><![CDATA[<p><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">232. Implement Queue using Stacks</a></p> <p>Double stack (input stack and output stack) Transfer the element in input stack when output stack is empty</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">stack1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">stack2</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/implement-stack-using-queues/description/">225. Implement Stack using Queues</a></p> <p><code class="language-plaintext highlighter-rouge">Queue</code>:</p> <ul> <li>initialization: <code class="language-plaintext highlighter-rouge">q = deque()</code></li> <li><code class="language-plaintext highlighter-rouge">q.append()</code>, <code class="language-plaintext highlighter-rouge">q.popleft()</code></li> </ul> <p><code class="language-plaintext highlighter-rouge">List</code>:</p> <ul> <li>initialization: <code class="language-plaintext highlighter-rouge">l = []</code></li> <li><code class="language-plaintext highlighter-rouge">l.append()</code>, <code class="language-plaintext highlighter-rouge">l.pop()</code></li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">MyStack</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
    

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># there is no pop in the queue
</span>        <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">())</span>
            <span class="c1"># [1, 2, 3]
</span>            <span class="c1"># [2, 3, 1]
</span>            <span class="c1"># [3, 1, 2]
</span>            <span class="c1"># not reverse, just move the last element to the begining
</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span>    
</code></pre></div></div> <p><a href="https://leetcode.com/problems/valid-parentheses/description/">20. Valid Parentheses</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">(</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">)</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">[</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">]</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">{</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">}</span><span class="sh">'</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">char</span> <span class="o">!=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">():</span> <span class="c1"># stack should not be empty in advance
</span>                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">stack</span> <span class="c1"># stack should be empty exactly when iterate all char in s
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/">1047. Remove All Adjacent Duplicates In String</a></p> <p>The index of <code class="language-plaintext highlighter-rouge">0</code> of stack: the first element: <code class="language-plaintext highlighter-rouge">''.join(stack)</code> equals to <code class="language-plaintext highlighter-rouge">''.join(list)</code></p> <p>The index of <code class="language-plaintext highlighter-rouge">-1</code> of stack: the last element(top)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">char</span> <span class="o">==</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">()</span>
        <span class="k">return</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/">150. Evaluate Reverse Polish Notation</a></p> <p><code class="language-plaintext highlighter-rouge">if token in '+-*/'</code>: Check whether token is not one of the characters <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, or <code class="language-plaintext highlighter-rouge">/</code>.</p> <p><code class="language-plaintext highlighter-rouge">a // b</code>: floor division (only when there is no negative integer between <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>) <code class="language-plaintext highlighter-rouge">int(a/b)</code>: truncate toward zero</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">evalRPN</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span> <span class="c1"># the order of iteration is from index 0 to index len(tokens)
</span>            <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">+-*/</span><span class="sh">'</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span> <span class="o">*</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">left</span><span class="o">/</span><span class="n">right</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Stack and Queue]]></summary></entry><entry><title type="html">HashMap, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Hashmap/" rel="alternate" type="text/html" title="HashMap, LeetCode"/><published>2025-06-13T15:32:13+00:00</published><updated>2025-06-13T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Hashmap</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Hashmap/"><![CDATA[<p><a href="https://leetcode.com/problems/valid-anagram/description/">242. Valid Anagram</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">validAnagram</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">-=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/intersection-of-two-arrays/description/">349. Intersection of Two Arrays</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">hashmap</span> <span class="ow">and</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
<span class="c1"># find the intersection: list(set(nums1) &amp; set(nums2))
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/two-sum/description/">1. Two Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">hashmap</span><span class="p">[</span><span class="n">comp</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/4sum-ii/description/">454. 4Sum II</a></p> <p>Return the number of tuple, instead of listing all tuple</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fourSumCount</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">num2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">num3</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">num4</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">nums1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">nums2</span><span class="p">:</span>
                <span class="n">_sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">_sum</span><span class="p">]</span> <span class="o">=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">_sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nums3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nums4</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">target</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/4sum/description/">18. 4Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fourSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">nums</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
                    <span class="n">_sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">_sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">_sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]])</span>
                        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to HashMap]]></summary></entry><entry><title type="html">String, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/String/" rel="alternate" type="text/html" title="String, LeetCode"/><published>2025-06-13T15:32:13+00:00</published><updated>2025-06-13T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/String</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/String/"><![CDATA[<p><a href="https://leetcode.com/problems/reverse-string/description/">344. Reverse String</a></p> <p><code class="language-plaintext highlighter-rouge">return s[::-1]</code> will create a new reversed list and <code class="language-plaintext highlighter-rouge">s</code> is not changed</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseString</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/reverse-string-ii/description/">541. Reverse String II</a></p> <p><code class="language-plaintext highlighter-rouge">s[i:j]</code> equals <code class="language-plaintext highlighter-rouge">[i, j)</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseStr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nf">reversed</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/reverse-words-in-a-string/description/">151. Reverse Words in a String</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
s = </span><span class="sh">"</span><span class="s">  hello   world  </span><span class="sh">"</span><span class="s">
s.split() -&gt; [</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">world</span><span class="sh">'</span><span class="s">]
s.split(</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="s">) -&gt; [</span><span class="sh">''</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">'</span><span class="s">world</span><span class="sh">'</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">''</span><span class="s">]
</span><span class="sh">"""</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseWords</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span>
        <span class="k">return</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># return ''.join(reversed(s))
</span></code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to String]]></summary></entry><entry><title type="html">Mock Interview(1), LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Mock-Interview(1)/" rel="alternate" type="text/html" title="Mock Interview(1), LeetCode"/><published>2025-06-10T18:32:13+00:00</published><updated>2025-06-10T18:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Mock-Interview(1)</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Mock-Interview(1)/"><![CDATA[<p><a href="https://leetcode.com/problems/graph-valid-tree/description/">261. Graph Valid Tree</a></p> <p>A tree with <code class="language-plaintext highlighter-rouge">n</code> nodes must have exactly <code class="language-plaintext highlighter-rouge">n - 1</code> edges</p> <ul> <li>More than <code class="language-plaintext highlighter-rouge">n - 1</code>: cycle</li> <li>Less than <code class="language-plaintext highlighter-rouge">n - 1</code>: not all nodes are connected: isolated nodes or a forest (multiple disconnected subtrees)</li> </ul> <p>Union-Find, Find:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
 <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="c1"># when parent[x] == x, then it is the true root
</span>        <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> 
        <span class="c1"># find the true father node of x
</span>        <span class="c1"># since the father node of x is parent[x], the father node of parent[x] is parent[parent[x]]
</span>        <span class="c1"># then the true father node of x is parent[parent[x]]
</span>        <span class="c1"># x is not the root, but parent[x] and parent[parent[x]] may be the root
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> 
        <span class="c1"># update the x
</span>    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">validTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># [[1, 2]], [[1], [2]] all belongs to Lits[List[int]]
</span>        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="c1"># each node is own root
</span>        
        <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">x</span>
        
        <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">rootA</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">rootB</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

            <span class="c1"># if rootA = rootB, it means they already connected, there is a cycle
</span>            <span class="k">if</span> <span class="n">rootA</span> <span class="o">==</span> <span class="n">rootB</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span> 
            
            <span class="k">if</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootA</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootB</span><span class="p">]:</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">rootB</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootA</span> 
                <span class="c1"># update the parent root
</span>            <span class="k">else</span><span class="p">:</span> 
                <span class="n">parent</span><span class="p">[</span><span class="n">rootA</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootB</span>
                <span class="n">rank</span><span class="p">[</span><span class="n">rootA</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nf">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/3sum/description/">15. 3Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">threeSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nums</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span> <span class="c1"># the nums should be in order
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1"># Avoid duplicate group result in same element for i index
</span>            <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">_sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">_sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">_sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]])</span>

                    <span class="c1"># Avoid duplicate group result in same elements for left/right index
</span>                    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="c1"># check left &lt; right first to avoid list index out of range
</span>                        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/continuous-subarray-sum/description/?envType=company&amp;envId=facebook&amp;favoriteSlug=facebook-thirty-days">523. Continuous Subarray Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">origin_num</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">prefix_sum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
<span class="n">reminder_5</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                 <span class="o">|</span>     <span class="o">|</span>
                    <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div></div> <p>If a certain remainder of the prefix sum modulo <code class="language-plaintext highlighter-rouge">k</code> first appears at index <code class="language-plaintext highlighter-rouge">i</code> and then again at index <code class="language-plaintext highlighter-rouge">j</code>, then the subarray <code class="language-plaintext highlighter-rouge">(i, j]</code> has a sum that is divisible by k</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkSubarraySum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
        <span class="n">_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">_sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">_sum</span> <span class="o">%</span> <span class="n">k</span>
            
            <span class="k">if</span> <span class="n">remainder</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems discussed during a mock interview on 2025-06-10]]></summary></entry></feed>