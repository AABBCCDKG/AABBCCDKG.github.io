<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://aabbccdkg.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://aabbccdkg.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-19T21:20:37+00:00</updated><id>https://aabbccdkg.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Mock Interview(1), LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Mock-Interview(2).md/" rel="alternate" type="text/html" title="Mock Interview(1), LeetCode"/><published>2025-07-18T18:32:13+00:00</published><updated>2025-07-18T18:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Mock-Interview(2).md</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Mock-Interview(2).md/"><![CDATA[<p><a href="https://leetcode.com/problems/minimum-window-substring/description/">76. Minimum Window Substring</a></p> <p>Part 1: Count the Frequency of characters in <code class="language-plaintext highlighter-rouge">t</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Firts way
</span><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="n">dict_t</span> <span class="o">=</span> <span class="nc">Count</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1"># C is capitalized
</span>
<span class="c1"># Second way
</span><span class="n">dict_t</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
    <span class="n">dict_t</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_t</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> 
    <span class="c1"># dict_t.get(char): get the value of dict_t[char]
</span>    <span class="c1"># dict_t.get(char, 0): get the value of dict_t[char], if there is no char in dict_t, return 0
</span></code></pre></div></div> <p>Part 2: Find a Window in <code class="language-plaintext highlighter-rouge">s</code> that contains those characters with required frequencies</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># general step:
</span><span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># window sliding is a double pointer problem
</span><span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">():</span>
    <span class="c1"># in what condition, we should shrink the window(move the left pointer to the right, most of time, it would be while loop)
</span></code></pre></div></div> <p>Formed: Whenever the frequency of a character in the current window exactly macthes the required count in <code class="language-plaintext highlighter-rouge">t</code>, do addition</p> <p>Required: the number of different type of character in <code class="language-plaintext highlighter-rouge">t</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minWindow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">dict_t</span> <span class="o">=</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">min_length</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">required</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">dict_t</span><span class="p">)</span>
        <span class="n">window_count</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">formed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_left</span> <span class="o">=</span><span class="mi">0</span>
        <span class="n">min_right</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">char</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="n">window_count</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">window_count</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">dict_t</span> <span class="ow">and</span> <span class="n">window_count</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">==</span> <span class="n">dict_t</span><span class="p">[</span><span class="n">char</span><span class="p">]:</span>
                <span class="n">formed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">formed</span> <span class="o">==</span> <span class="n">required</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">min_length</span><span class="p">:</span>
                    <span class="n">min_length</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">min_length</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">min_left</span> <span class="o">=</span> <span class="n">left</span>
                    <span class="n">min_right</span> <span class="o">=</span> <span class="n">right</span>
                <span class="n">window_count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="ow">in</span> <span class="n">dict_t</span> <span class="ow">and</span> <span class="n">window_count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">dict_t</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]:</span>
                    <span class="n">formed</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="sh">""</span> <span class="k">if</span> <span class="n">min_length</span> <span class="o">==</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span> <span class="k">else</span> <span class="n">s</span><span class="p">[</span><span class="n">min_left</span><span class="p">:</span> <span class="n">min_right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># min_length == float('inf') means throughout the entire traversal, no valid window that satisfies the condition was ever found,
</span>        <span class="c1">#  so min_length was never updated: no need to do the check: if len(s) &lt; len(t)
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">3. Longest Substring Without Repeating Characters</a></p> <p>Window means there are two pointers: <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code></p> <p><code class="language-plaintext highlighter-rouge">set()</code> is unordered, but it allows <code class="language-plaintext highlighter-rouge">O(1)</code> time complexity for checking the existence of an element.</p> <p>For sliding window problems, the typical patter is:</p> <ul> <li>At each step, expand the window by moving the right pointer, and then shrink the window from the left as needed to maintain the desired condition (window sliding is a double pointer problem)</li> </ul> <p>The <code class="language-plaintext highlighter-rouge">set</code> object does not support <code class="language-plaintext highlighter-rouge">.append()</code> - use <code class="language-plaintext highlighter-rouge">.add()</code> to insert elements and <code class="language-plaintext highlighter-rouge">.remove()</code> to delete them</p> <p>When shrinking the window, it’s often not enough to remove a single element. You should use a <code class="language-plaintext highlighter-rouge">while</code> loop to continue shrinking the window from the left until the condition is satisfied again.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">char_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">while</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="ow">in</span> <span class="n">char_set</span><span class="p">:</span>
                <span class="n">char_set</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">])</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">char_set</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>
            <span class="n">max_length</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_length</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">max_length</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems discussed during a mock interview on 2025-07-18]]></summary></entry><entry><title type="html">Binary Tree, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Tree/" rel="alternate" type="text/html" title="Binary Tree, LeetCode"/><published>2025-06-15T15:32:13+00:00</published><updated>2025-06-15T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Tree</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Tree/"><![CDATA[<p>Full Binary Tree (Proper Binary Tree)</p> <ul> <li>every node has either exactly two children or no children.</li> </ul> <p>Perfect Binary Tree (Strictly Full Binary Tree):</p> <ul> <li>Every internal node has two children</li> <li>All leaf nodes appear at the same depth(level).</li> <li>Level (k) start from 0 <ul> <li>Every level has <code class="language-plaintext highlighter-rouge">2^k</code> nodes (Level(k) start from 0).</li> <li>Total nodes: <code class="language-plaintext highlighter-rouge">2^(k+1) - 1</code>.</li> </ul> </li> <li>Level (k) start from 1 <ul> <li>Every level has <code class="language-plaintext highlighter-rouge">2^(k - 1)</code>. nodes (Level(k) start from 0)</li> <li>Total nodes: <code class="language-plaintext highlighter-rouge">2^(k) - 1</code>.</li> </ul> </li> </ul> <p>Complete Binary Tree:</p> <ul> <li>Every level, except possibly the last, is completely filled.</li> <li>In the last level, all nodes are as far left as possible, with no “gaps” between them.</li> <li>heap is a complete binary tree.</li> </ul> <p>Binary Search Tree:</p> <ul> <li>Average case for search and insert: O(log n) when the tree is approximately balanced (each comparison eliminates about half of the remaining nodes).</li> <li>Worst case for search and insert: O(n) if the tree becomes completely unbalanced (degenerates into a chain).</li> <li>Left -&gt; Small, Top -&gt; Medium, Right -&gt; Big</li> <li>No requirement for node structure</li> </ul> <p>Balanced Binary Search Tree:</p> <ul> <li>∀ N: height(N.left) – height(N.right) ≤ 1</li> <li>the basic of map and set (the key in map and the element in set is in order)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Initialization by Linked List:
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="c1"># Initialization by List:
</span><span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">curr</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> 
<span class="n">left_children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">right_children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div> <p>Using backtracking to build binary tree</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">list_to_complete_binary_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nf">list_to_complete_binary_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nf">list_to_complete_binary_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div> <p>DFS:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># result should be the input of dfs, so that every recursive call will write into the same list
# pre-order
</span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="c1"># middle
</span>    <span class="n">left_branch</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># left
</span>    <span class="n">right_branch</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1"># right
</span>    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p>BFS</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span> <span class="c1"># queue stores node instead of the value of node
</span>    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">length_of_level</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length_of_level</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">144. Binary Tree Preorder Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1: _dfs accept result as input
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> 
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># stop iteration
</span>        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">left_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="c1"># 2. _dfs doesn't accept result as input
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span> <span class="c1"># return value
</span>        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># return the value of left_branch
</span>        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="c1"># left and right are all list 
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/">145. Binary Tree Postorder Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__ini__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
    
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__ini__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
    
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>
<span class="c1"># Or
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="p">[]</span> <span class="c1"># in case _dfs only run the first two line code
</span>    
    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">left_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">94. Binary Tree Inorder Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">left_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">right_branch</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_dfs</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
<span class="c1"># Or
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/">102. Binary Tree Level Order Traversal</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
    
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">length_of_level</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length_of_level</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/invert-binary-tree/description/">226. Invert Binary Tree</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span> <span class="c1"># Al
</span>        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span> 
            <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            <span class="c1"># Using parallel assignment in python 
</span>            <span class="c1"># temp = node.left
</span>            <span class="c1"># node.left = node.right
</span>            <span class="c1"># node.right = temp
</span>            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/symmetric-tree/description/">101. Symmetric Tree</a></p> <p><code class="language-plaintext highlighter-rouge">len(nums)</code> is even:</p> <ul> <li><code class="language-plaintext highlighter-rouge">len(nums) // 2</code> returns the left middle index.</li> <li><code class="language-plaintext highlighter-rouge">math.ceil(nums / 2)</code> returns the right middle index.</li> </ul> <p><code class="language-plaintext highlighter-rouge">len(nums)</code> is odd:</p> <ul> <li>both return the middle one</li> </ul> <p>queue could also store a tuple <code class="language-plaintext highlighter-rouge">(node.left, node.right)</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">right</span> <span class="ow">or</span> <span class="n">left</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">left</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">.</span><span class="n">right</span><span class="p">))</span> 
            <span class="c1"># compare whether the whole tree is symmetric
</span>            <span class="c1"># queue.append((left.left, left.right)): compare the left branch of left is symmetric or not
</span>            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">right</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">right</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">104. Maximum Depth of Binary Tree</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span> 
            <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">depth</span>
        <span class="c1"># In most problems, it doesn't matter whether 
</span>        <span class="c1"># you place operations like +1, updates, 
</span>        <span class="c1"># or returns at the beginning or end of a loop. 
</span>        <span class="c1"># Confused about the initial value of depth? move the position (beginning is more reasonable)
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/">111. Minimum Depth of Binary Tree</a></p> <p><code class="language-plaintext highlighter-rouge">leaf node</code>: both <code class="language-plaintext highlighter-rouge">node.left</code> and <code class="language-plaintext highlighter-rouge">node.right</code> are <code class="language-plaintext highlighter-rouge">None</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">depth</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/count-complete-tree-nodes/description/">222. Count Complete Tree Nodes</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">getDepth</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="n">depth_of_left_branch</span> <span class="o">=</span> <span class="nf">getDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># getDepth is the method in countNodes, no need for self when using getDepth in countNodes
</span>        <span class="n">depth_of_right_branch</span> <span class="o">=</span> <span class="nf">getDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">depth_of_left_branch</span> <span class="o">==</span> <span class="n">depth_of_right_branch</span><span class="p">:</span>
            <span class="c1"># the left branch is full
</span>            <span class="k">return</span> <span class="mi">2</span><span class="o">^</span><span class="n">depth_of_left_branch</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> 
            <span class="c1"># + 1 is counting node itself
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the right branch is full
</span>            <span class="k">return</span> <span class="mi">2</span><span class="o">^</span><span class="n">depth_of_right_branch</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">counNodes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/balanced-binary-tree/description/">110. Balanced Binary Tree</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Some changes based on getDepth
        def getDepth(node):
            if not node:
                return 0
            left = getDepth(node.left)
            # could be filled for the operations on left branch
            right = getDepth(node.right)
            # could be filled for the operations on right branch

            # could be filled for the operation on current node
            return max(left, right) + 1
        </span><span class="sh">"""</span>
        <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            
            <span class="n">left</span> <span class="o">=</span> <span class="nf">check</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">right</span> <span class="o">=</span> <span class="nf">check</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">right</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

            <span class="k">if</span> <span class="nf">abs</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nf">check</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/binary-tree-paths/description/">257. Binary Tree Paths</a></p> <p><code class="language-plaintext highlighter-rouge">Process currnt node</code></p> <ul> <li>update the state <ul> <li>Add the node’s information into global state or the state passed as a parameter. <ul> <li>path problem: state.path.append(node.val)</li> <li>sum problems: state.sum += node.val</li> <li>min/max problems: state.best = max(state.best, node.val)</li> <li>graph visits: state.visited.add(node)</li> </ul> </li> </ul> </li> <li>Check or Record the result <ul> <li>If the current state meets your goal, then save to your results list and optionally return/prune. <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
  <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
  <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
  <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
  <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
          <span class="k">return</span>
      <span class="c1"># ending condition:information to global state
</span>      <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
          <span class="n">paths</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
          <span class="k">return</span>

      <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
          <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="sh">'</span><span class="s">-&gt;</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
            
      <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
          <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="sh">'</span><span class="s">-&gt;</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
      <span class="nf">_dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nf">str</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">paths</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <p><a href="https://leetcode.com/problems/sum-of-left-leaves/description/">404. Sum of Left Leaves</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">_sum</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> 
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="c1"># No matter whether node itself has a right child or not, it does not affect whether node.left is a leaf node.
</span>                <span class="n">_sum</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span>
            <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="nf">_dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="nf">_dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_sum</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/">513. Find Bottom Left Tree Value</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Rock</span> <span class="n">find</span> <span class="n">the</span> <span class="n">email</span>
<span class="n">Jeff</span> <span class="n">email</span>
<span class="n">Nacy</span><span class="p">:</span> <span class="n">linancy</span><span class="nd">@amazon.com</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"""

Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".

The testcases will be generated such that the answer is unique.

 

Example 1:

Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
Example 2:

Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
Example 3:

Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
 

Constraints:

m == s.length
n == t.length
1 &lt;= m, n &lt;= 105
s and t consist of uppercase and lowercase English letters.
 

Follow up: Could you find an algorithm that runs in O(m + n) time?


"""
"""
sliding window -&gt; iterate the str s
simulate the substring

hashmap -&gt; record the ocurrance of character while doing the iteration


Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"

need_hashmap = {'A': 1, 'B': 1, 'C': 1}
window = {}
have = 0
required = len(t)
have == testcases
left, right: boundary of window
right -&gt; A (index 0 in s) window['A'] = 1
right -&gt; D (index 1 in s) 
right -&gt; B window['B'] = 1

TC: O(len(s) + len(t))
SC:O(max(len(s), len(t)))

"""
from collections import Counter

class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        need_hashmap = Counter(t)
        window_hashmap = {}
        required_length = len(need_hashmap)
        current = 0

        left = 0
        right = 0
        min_length = float('inf')
        ans_left, ans_right = 0, 0

        while right &lt; len(s):
            char = s[right]
            if char in need_hashmap:
                window_hashmap[char] = window_hashmap.get(char, 0) + 1
                if window_hashmap[char] == need_hashmap[char]:
                    current += 1
            while left &lt;= right and current == required_length:
                _size = right - left + 1 # right - left -&gt; [left, right)
                # update the ans_left, ans_right
                if _size &lt; min_length:
                    min_length = _size
                    ans_left, ans_right = left, right
                left_char = s[left]
                # print(left_char)
                if left_char in need_hashmap:
                    window_hashmap[left_char] -= 1
                    if window_hashmap[left_char] &lt; need_hashmap[left_char]:
                        current -= 1
                left += 1
            right += 1
        # print(min_length)
        return s[ans_left:ans_right + 1] if min_length != float('inf') else ''
solver = Solution()
print('check',solver.minWindow("ADOBECODEBANC", "ABC"))
print('check',solver.minWindow("a", "a"))
print('check',solver.minWindow("a", "aa"))



"""
Number of Paths
You’re testing a new driverless car that is located at the Southwest (bottom-left) corner of an n×n grid. The car is supposed to get to the opposite, Northeast (top-right), corner of the grid. Given n, the size of the grid’s axes, write a function numOfPathsToDest that returns the number of the possible paths the driverless car can take.


the car may move only in the white squares

For convenience, let’s represent every square in the grid as a pair (i,j). The first coordinate in the pair denotes the east-to-west axis, and the second coordinate denotes the south-to-north axis. The initial state of the car is (0,0), and the destination is (n-1,n-1).

The car must abide by the following two rules: it cannot cross the diagonal border. In other words, in every step the position (i,j) needs to maintain i &gt;= j. See the illustration above for n = 5. In every step, it may go one square North (up), or one square East (right), but not both. E.g. if the car is at (3,1), it may go to (3,2) or (4,1).

Explain the correctness of your function, and analyze its time and space complexities.

Example:

5. [N] [N] [N] [N] [ ]
4. [N] [N] [N] [ ] [ ]
3. [N] [N] [ ] [ ] [ ]
2. [N] [ ] [ ] [ ] [ ]
1. [ ] [ ] [ ] [ ] [ ]
0.    1   2   3   4   5

input:  n = 4

output: 5 # since there are five possibilities:
          # “EEENNN”, “EENENN”, “ENEENN”, “ENENEN”, “EENNEN”,
          # where the 'E' character stands for moving one step
          # East, and the 'N' character stands for moving one step
          # North (so, for instance, the path sequence “EEENNN”
          # stands for the following steps that the car took:
          # East, East, East, North, North, North)
Constraints:

[time limit] 5000ms

[input] integer n

1 ≤ n ≤ 100
[output] integer


dp[][]
border: 
    


3 [a, b, c, 1]
2 [a, b, 1, d]
1 [a, 1, 2, d]
0 [1, 1, 1, d]
   0, 1, 2, 3
n = 4
target: (3, 3)

dp[0][0] = 1
dp[1][0] = 1
dp[1][1] = 1
dp[2][0] = 1
dp[2][1] = dp[1][1] + dp[2][0] = 1 + 1 =2

dp[i][0] = 1 (from (0, 0) to (i, 0))
dp[i][i] = 1 (diagonal)
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
return dp[n - 1][n - 1]
"""



def num_of_paths_to_dest(n: int) -&gt; int:
    dp = [[0] * n for _ in range(n)]
    for i in range(n):
        dp[i][0] = 1
        dp[i][i] = 1

    for i in range(1, n):
        for j in range(1, i + 1):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    return dp[n - 1][n - 1]


print(num_of_paths_to_dest(4))
print(num_of_paths_to_dest(3))
print(num_of_paths_to_dest(17))

"""
input:  n = 4, 3, 17
output: 5, 2, 35357670
"""


【Attention】Great opportunities from TikTok
Hi Wen, 

Hope you are doing well! This is Xuewei from TikTok Talent Acquisition team.

We are opening Software Engineer positions for our TikTok San Jose Office. Please share an updated copy of your resume if you are interested in it! 

Look forward to hearing back from you. 

Kind regards,

Xuewei Liu
TikTok Acquisition Team
Email: xueweiliu@bytedance.com
https://www.linkedin.com/in/xuewei-liu-03b593334/
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Tree]]></summary></entry><entry><title type="html">NVIDIA, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Nvidia/" rel="alternate" type="text/html" title="NVIDIA, LeetCode"/><published>2025-06-14T16:32:13+00:00</published><updated>2025-06-14T16:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Nvidia</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Nvidia/"><![CDATA[<p><a href="https://leetcode.com/problems/product-of-array-except-self/description/?envType=company&amp;envId=nvidia&amp;favoriteSlug=nvidia-three-months">238. Product of Array Except Self</a></p> <p>When there are no elements to multiple at a certain position, the product should be initialized as <code class="language-plaintext highlighter-rouge">1</code>, since <code class="language-plaintext highlighter-rouge">1</code> is the identity element for multiplication and does not affect the overall result. That is the reason why <code class="language-plaintext highlighter-rouge">left_prod</code> and <code class="language-plaintext highlighter-rouge">right_prod</code> are both initialized as <code class="language-plaintext highlighter-rouge">1</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">productExceptSelf</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">left_prod</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">right_prod</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="c1"># append the left_prod first, update the left_prod with current element second to except self
</span>            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left_prod</span><span class="p">)</span>
            <span class="n">left_prod</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">right_prod</span>
            <span class="n">right_prod</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/group-anagrams/description/?envType=company&amp;envId=nvidia&amp;favoriteSlug=nvidia-three-months">49. Group Anagrams</a></p> <p>When you’re comparing elements in a list pairwise, <code class="language-plaintext highlighter-rouge">hashmap</code> could reduce the time complexity from <code class="language-plaintext highlighter-rouge">O(n^2)</code> to <code class="language-plaintext highlighter-rouge">O(n)</code> using a key with distinguishing or grouping capability.</p> <p><code class="language-plaintext highlighter-rouge">Anagram: same after sorting</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">groupAnagrams</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="c1"># sorted(word) will return a list
</span>            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">]</span>
        <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">hashmap</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span> 
        <span class="c1"># list(hashmap.keys())
</span>        <span class="c1"># list(hashmap.values()) 
</span>        <span class="c1"># list(hashmap.items()) List[tuple]
</span></code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems frequently asked by NVIDIA]]></summary></entry><entry><title type="html">Stack and Queue, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Stack-and-Queue/" rel="alternate" type="text/html" title="Stack and Queue, LeetCode"/><published>2025-06-14T15:32:13+00:00</published><updated>2025-06-14T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Stack-and-Queue</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Stack-and-Queue/"><![CDATA[<p><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">232. Implement Queue using Stacks</a></p> <p>Double stack (input stack and output stack) Transfer the element in input stack when output stack is empty</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">stack1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">stack2</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">stack1</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">stack2</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/implement-stack-using-queues/description/">225. Implement Stack using Queues</a></p> <p><code class="language-plaintext highlighter-rouge">Queue</code>:</p> <ul> <li>initialization: <code class="language-plaintext highlighter-rouge">q = deque()</code></li> <li><code class="language-plaintext highlighter-rouge">q.append()</code>, <code class="language-plaintext highlighter-rouge">q.popleft()</code></li> </ul> <p><code class="language-plaintext highlighter-rouge">List</code>:</p> <ul> <li>initialization: <code class="language-plaintext highlighter-rouge">l = []</code></li> <li><code class="language-plaintext highlighter-rouge">l.append()</code>, <code class="language-plaintext highlighter-rouge">l.pop()</code></li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">MyStack</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
    

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># there is no pop in the queue
</span>        <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">())</span>
            <span class="c1"># [1, 2, 3]
</span>            <span class="c1"># [2, 3, 1]
</span>            <span class="c1"># [3, 1, 2]
</span>            <span class="c1"># not reverse, just move the last element to the begining
</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span>    
</code></pre></div></div> <p><a href="https://leetcode.com/problems/valid-parentheses/description/">20. Valid Parentheses</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">(</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">)</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">[</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">]</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">{</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">}</span><span class="sh">'</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">char</span> <span class="o">!=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">():</span> <span class="c1"># stack should not be empty in advance
</span>                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">stack</span> <span class="c1"># stack should be empty exactly when iterate all char in s
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/">1047. Remove All Adjacent Duplicates In String</a></p> <p>The index of <code class="language-plaintext highlighter-rouge">0</code> of stack: the first element: <code class="language-plaintext highlighter-rouge">''.join(stack)</code> equals to <code class="language-plaintext highlighter-rouge">''.join(list)</code></p> <p>The index of <code class="language-plaintext highlighter-rouge">-1</code> of stack: the last element(top)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">char</span> <span class="o">==</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">()</span>
        <span class="k">return</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/">150. Evaluate Reverse Polish Notation</a></p> <p><code class="language-plaintext highlighter-rouge">if token in '+-*/'</code>: Check whether token is not one of the characters <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, or <code class="language-plaintext highlighter-rouge">/</code>.</p> <p><code class="language-plaintext highlighter-rouge">a // b</code>: floor division (only when there is no negative integer between <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>) <code class="language-plaintext highlighter-rouge">int(a/b)</code>: truncate toward zero</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">evalRPN</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span> <span class="c1"># the order of iteration is from index 0 to index len(tokens)
</span>            <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">+-*/</span><span class="sh">'</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span> <span class="o">*</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">left</span><span class="o">/</span><span class="n">right</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Stack and Queue]]></summary></entry><entry><title type="html">HashMap, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Hashmap/" rel="alternate" type="text/html" title="HashMap, LeetCode"/><published>2025-06-13T15:32:13+00:00</published><updated>2025-06-13T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Hashmap</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Hashmap/"><![CDATA[<p><a href="https://leetcode.com/problems/valid-anagram/description/">242. Valid Anagram</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">validAnagram</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">-=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/intersection-of-two-arrays/description/">349. Intersection of Two Arrays</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">hashmap</span> <span class="ow">and</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
<span class="c1"># find the intersection: list(set(nums1) &amp; set(nums2))
</span></code></pre></div></div> <p><a href="https://leetcode.com/problems/two-sum/description/">1. Two Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">hashmap</span><span class="p">[</span><span class="n">comp</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/4sum-ii/description/">454. 4Sum II</a></p> <p>Return the number of tuple, instead of listing all tuple</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fourSumCount</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">num2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">num3</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">num4</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">nums1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">nums2</span><span class="p">:</span>
                <span class="n">_sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">_sum</span><span class="p">]</span> <span class="o">=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">_sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nums3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nums4</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">target</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/4sum/description/">18. 4Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fourSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">nums</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
                    <span class="n">_sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">_sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">_sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]])</span>
                        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to HashMap]]></summary></entry><entry><title type="html">String, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/String/" rel="alternate" type="text/html" title="String, LeetCode"/><published>2025-06-13T15:32:13+00:00</published><updated>2025-06-13T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/String</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/String/"><![CDATA[<p><a href="https://leetcode.com/problems/reverse-string/description/">344. Reverse String</a></p> <p><code class="language-plaintext highlighter-rouge">return s[::-1]</code> will create a new reversed list and <code class="language-plaintext highlighter-rouge">s</code> is not changed</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseString</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/reverse-string-ii/description/">541. Reverse String II</a></p> <p><code class="language-plaintext highlighter-rouge">s[i:j]</code> equals <code class="language-plaintext highlighter-rouge">[i, j)</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseStr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nf">reversed</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/reverse-words-in-a-string/description/">151. Reverse Words in a String</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
s = </span><span class="sh">"</span><span class="s">  hello   world  </span><span class="sh">"</span><span class="s">
s.split() -&gt; [</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">world</span><span class="sh">'</span><span class="s">]
s.split(</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="s">) -&gt; [</span><span class="sh">''</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">'</span><span class="s">world</span><span class="sh">'</span><span class="s">, </span><span class="sh">''</span><span class="s">, </span><span class="sh">''</span><span class="s">]
</span><span class="sh">"""</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseWords</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span>
        <span class="k">return</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># return ''.join(reversed(s))
</span></code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to String]]></summary></entry><entry><title type="html">Mock Interview(1), LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Mock-Interview(1)/" rel="alternate" type="text/html" title="Mock Interview(1), LeetCode"/><published>2025-06-10T18:32:13+00:00</published><updated>2025-06-10T18:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Mock-Interview(1)</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Mock-Interview(1)/"><![CDATA[<p><a href="https://leetcode.com/problems/graph-valid-tree/description/">261. Graph Valid Tree</a></p> <p>A tree with <code class="language-plaintext highlighter-rouge">n</code> nodes must have exactly <code class="language-plaintext highlighter-rouge">n - 1</code> edges</p> <ul> <li>More than <code class="language-plaintext highlighter-rouge">n - 1</code>: cycle</li> <li>Less than <code class="language-plaintext highlighter-rouge">n - 1</code>: not all nodes are connected: isolated nodes or a forest (multiple disconnected subtrees)</li> </ul> <p>Union-Find, Find:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
 <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="c1"># when parent[x] == x, then it is the true root
</span>        <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> 
        <span class="c1"># find the true father node of x
</span>        <span class="c1"># since the father node of x is parent[x], the father node of parent[x] is parent[parent[x]]
</span>        <span class="c1"># then the true father node of x is parent[parent[x]]
</span>        <span class="c1"># x is not the root, but parent[x] and parent[parent[x]] may be the root
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> 
        <span class="c1"># update the x
</span>    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">validTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># [[1, 2]], [[1], [2]] all belongs to Lits[List[int]]
</span>        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="c1"># each node is own root
</span>        
        <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">x</span>
        
        <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">rootA</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">rootB</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

            <span class="c1"># if rootA = rootB, it means they already connected, there is a cycle
</span>            <span class="k">if</span> <span class="n">rootA</span> <span class="o">==</span> <span class="n">rootB</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span> 
            
            <span class="k">if</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootA</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootB</span><span class="p">]:</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">rootB</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootA</span> 
                <span class="c1"># update the parent root
</span>            <span class="k">else</span><span class="p">:</span> 
                <span class="n">parent</span><span class="p">[</span><span class="n">rootA</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootB</span>
                <span class="n">rank</span><span class="p">[</span><span class="n">rootA</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nf">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/3sum/description/">15. 3Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">threeSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nums</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span> <span class="c1"># the nums should be in order
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1"># Avoid duplicate group result in same element for i index
</span>            <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">_sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">_sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">_sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]])</span>

                    <span class="c1"># Avoid duplicate group result in same elements for left/right index
</span>                    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="c1"># check left &lt; right first to avoid list index out of range
</span>                        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/continuous-subarray-sum/description/?envType=company&amp;envId=facebook&amp;favoriteSlug=facebook-thirty-days">523. Continuous Subarray Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">origin_num</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">prefix_sum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
<span class="n">reminder_5</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                 <span class="o">|</span>     <span class="o">|</span>
                    <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div></div> <p>If a certain remainder of the prefix sum modulo <code class="language-plaintext highlighter-rouge">k</code> first appears at index <code class="language-plaintext highlighter-rouge">i</code> and then again at index <code class="language-plaintext highlighter-rouge">j</code>, then the subarray <code class="language-plaintext highlighter-rouge">(i, j]</code> has a sum that is divisible by k</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkSubarraySum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
        <span class="n">_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">_sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">_sum</span> <span class="o">%</span> <span class="n">k</span>
            
            <span class="k">if</span> <span class="n">remainder</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hashmap</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems discussed during a mock interview on 2025-06-10]]></summary></entry><entry><title type="html">Meta, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Meta/" rel="alternate" type="text/html" title="Meta, LeetCode"/><published>2025-06-10T16:32:13+00:00</published><updated>2025-06-10T16:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Meta</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Meta/"><![CDATA[<p><a href="https://leetcode.com/problems/buildings-with-an-ocean-view/description/?envType=company&amp;envId=facebook&amp;favoriteSlug=facebook-thirty-days">1762. Buildings With an Ocean View</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Wrong
</span><span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span> <span class="c1"># .sort() returns None
</span>
<span class="c1"># Correct: sort() is O(nlogn)
</span><span class="n">result</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
<span class="k">return</span> <span class="n">result</span>

<span class="c1"># Better: remove sort(), use [::-1] to reverse list, O(n)
</span><span class="k">return</span> <span class="n">result</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findBuildings</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">heights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">max_heights</span> <span class="o">=</span> <span class="n">heights</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_heights</span><span class="p">:</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">max_heights</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_heights</span><span class="p">,</span> <span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems frequently asked by Meta]]></summary></entry><entry><title type="html">Linked List, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/LinkedList/" rel="alternate" type="text/html" title="Linked List, LeetCode"/><published>2025-06-10T15:32:13+00:00</published><updated>2025-06-10T15:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/LinkedList</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/LinkedList/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="c1"># '=' assigns value
</span>        <span class="c1"># ':' type annotation
</span>        <span class="c1"># val: int = 0
</span>        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for doubly-linked list
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
        <span class="n">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span>
</code></pre></div></div> <p>Since ListNode may be <code class="language-plaintext highlighter-rouge">None</code>, so the type annotation should be Optional[ListNode]</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]):</span>
</code></pre></div></div> <p>Check <code class="language-plaintext highlighter-rouge">curr.next</code> for deletion of Linked List, so use <code class="language-plaintext highlighter-rouge">while curr.next</code> instead of <code class="language-plaintext highlighter-rouge">while curr</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeElements</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy_head</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dummy_head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">dummy_head</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
                <span class="c1"># curr.next is updated, check it 
</span>                <span class="c1"># again without moving curr forward 
</span>                <span class="c1"># otherwise, might skip consecutive target nodes.
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">dummy_head</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/design-linked-list/description/">707. Design Linked List</a></p> <p><code class="language-plaintext highlighter-rouge">return None</code> equals to <code class="language-plaintext highlighter-rouge">return</code> (end the function in advance)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
            <span class="n">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span>
    
    <span class="k">class</span> <span class="nc">MyLinkedList</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tail</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
            <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            
            <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span> 
            <span class="c1"># use self.head: iterate index + 1 times, i could be index
</span>            <span class="c1"># use self.head.next: iterate index times, 
</span>            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
                <span class="c1"># during this block, curr is the node at position i
</span>            <span class="k">return</span> <span class="n">curr</span><span class="p">.</span><span class="n">val</span>

        <span class="k">def</span> <span class="nf">addAtHead</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">addAtIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="c1"># no need for updating self.size
</span>        
        <span class="k">def</span> <span class="nf">addAtTail</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">addAtIndex</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="c1"># no need for updating self.size
</span>        
        <span class="k">def</span> <span class="nf">addAtIndex</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>

            <span class="n">pred</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">prev</span>
            <span class="n">suc</span> <span class="o">=</span> <span class="n">curr</span> <span class="c1"># move afterward, so suc is curr instead of curr.next
</span>            <span class="n">curr</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">pred</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="n">curr</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">pred</span>
            <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">suc</span>
            <span class="n">suc</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>
    
        <span class="k">def</span> <span class="nf">deleteAtIndex</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
            
            <span class="n">pred</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">prev</span>
            <span class="n">suc</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">pred</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">suc</span>
            <span class="n">suc</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">pred</span>
            <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/reverse-linked-list/description/">206. Reverse Linked List</a></p> <p>The entire operation consists of rerouting the single pointer among <code class="language-plaintext highlighter-rouge">curr</code>, <code class="language-plaintext highlighter-rouge">pred</code>, and <code class="language-plaintext highlighter-rouge">suc</code>: replacing <code class="language-plaintext highlighter-rouge">curr.next = suc</code> with <code class="language-plaintext highlighter-rouge">curr.next = pred</code>. So there is no pointer exsiting between <code class="language-plaintext highlighter-rouge">curr</code> and <code class="language-plaintext highlighter-rouge">pred</code>, otherwise there will be a cycle. - why initialize <code class="language-plaintext highlighter-rouge">pred</code> as <code class="language-plaintext highlighter-rouge">None</code> instead of <code class="language-plaintext highlighter-rouge">dummy_head (dummy_head.next = head)</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LitsNode</span><span class="p">]):</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">:</span> <span class="c1"># check
</span>            <span class="n">suc</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="c1"># adjust
</span>            <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">pred</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">curr</span> <span class="c1"># move
</span>            <span class="n">cur</span> <span class="o">=</span> <span class="n">succ</span> 
        <span class="k">return</span> <span class="n">pred</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/">24. Swap Nodes in Pairs</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">swapPairs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy_head</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dummy_head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">dummy_head</span>
        <span class="c1">#        [0,   1,   2,    3]
</span>        <span class="c1"># pred, curr, suc
</span>        <span class="k">while</span> <span class="n">pred</span><span class="p">.</span><span class="nb">next</span> <span class="ow">and</span> <span class="n">pred</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
        <span class="c1"># the length must be even
</span>            <span class="n">curr</span> <span class="o">=</span> <span class="n">pred</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">suc</span> <span class="o">=</span> <span class="n">pred</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>

            <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">suc</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">pred</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">suc</span>
            <span class="n">suc</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr</span>

            <span class="n">pred</span> <span class="o">=</span> <span class="n">curr</span>
        <span class="k">return</span> <span class="n">dummy_head</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/">19. Remove Nth Node From End of List</a></p> <p>Steps:</p> <ul> <li>These are number of loop iterations (for/while)</li> <li>To reach the n-th node in the linked list, you need <code class="language-plaintext highlighter-rouge">n - 1</code> steps (<code class="language-plaintext highlighter-rouge">n - 1</code> loop iterations)</li> </ul> <p>Elements:</p> <ul> <li>This is the count of items in a range</li> <li>For index <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>, <code class="language-plaintext highlighter-rouge">right - left</code> calculates the length (the number of elements) of interval <code class="language-plaintext highlighter-rouge">[left, right)</code></li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">next</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]):</span>
        <span class="n">dummy_head</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dummy_head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">fast</span><span class="p">,</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">dummy_head</span>
        <span class="c1"># move fast n + 1 steps to make sure there are only n nodes between fast and slow
</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>

        <span class="k">while</span> <span class="n">fast</span><span class="p">:</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">slow</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/">142. Linked List Cycle II</a></p> <p>In the cycle, <code class="language-plaintext highlighter-rouge">fast</code> pointer is chasing <code class="language-plaintext highlighter-rouge">slow</code> pointer, and the relative velocity between <code class="language-plaintext highlighter-rouge">fast</code> and <code class="language-plaintext highlighter-rouge">slow</code> pointers are <code class="language-plaintext highlighter-rouge">2 - 1 = 1</code>, so they will meet for sure</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">detectCycle</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">fast</span><span class="p">,</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">slow</span><span class="p">:</span>
                <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span>
                <span class="k">while</span> <span class="n">fast</span> <span class="o">!=</span> <span class="n">slow</span><span class="p">:</span>
                    <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>
                    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
                <span class="k">return</span> <span class="n">slow</span>
        <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Linked List]]></summary></entry><entry><title type="html">Array, LeetCode</title><link href="https://aabbccdkg.github.io/blog/2025/Array/" rel="alternate" type="text/html" title="Array, LeetCode"/><published>2025-06-10T00:32:13+00:00</published><updated>2025-06-10T00:32:13+00:00</updated><id>https://aabbccdkg.github.io/blog/2025/Array</id><content type="html" xml:base="https://aabbccdkg.github.io/blog/2025/Array/"><![CDATA[<p><a href="https://leetcode.com/problems/binary-search/description/">704. Binary Search</a></p> <p>To calculate the middle index: use <code class="language-plaintext highlighter-rouge">(left + right) // 2</code>, where <code class="language-plaintext highlighter-rouge">//</code> denotes floor division. When the number of elements is even, the fomular returns the left-middle index.</p> <p>Optimization: <code class="language-plaintext highlighter-rouge">left + (right - left) // 2</code> - Avoid integer overflow caused by a too large <code class="language-plaintext highlighter-rouge">right + left</code> through interval offset</p> <p>Why O(log(n))?</p> <ul> <li>Each iteration eliminates half of elements</li> <li>Search Space shrinks exponentially <ul> <li>1st iteration: n elements</li> <li>2st iteration: n/2 elements</li> </ul> </li> <li>At most log(n) comparisons are needed <ul> <li>2^k = n, log(n) = k</li> </ul> </li> <li>Stop in advance (<code class="language-plaintext highlighter-rouge">nums[middle] == target</code>) before checking all search space (<code class="language-plaintext highlighter-rouge">left == right</code>)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]:</span> 
                <span class="c1"># target is smaller, search the left half and update the right boundary
</span>                <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]:</span> 
                <span class="c1"># target is bigger, search the right half and update the left boundary
</span>                <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">middle</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/remove-element/description/">27. Remove Element</a></p> <p>Run test cases:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
    <span class="k">assert</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># assertion error
</span></code></pre></div></div> <p>The algorithm aims to remove elements. Using <code class="language-plaintext highlighter-rouge">nums[j] == val</code> finds elements to delete, but deletion is essentially “doing nothing”. The elements that actually need operations are those where <code class="language-plaintext highlighter-rouge">nums[j] != val</code> (preserve and move postions)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeElement</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fast</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span> <span class="c1"># we need to do some operations 
</span>                <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span>
                <span class="n">slow</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">slow</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/squares-of-a-sorted-array/description/">977. Squares of a Sorted Array</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># left, right pointers:
</span><span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
    <span class="c1"># dynamic boundaries
</span>    <span class="c1"># last iteration: left == right (can terminate early)
</span></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># slow, fast pointers:
</span><span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">fast</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
    <span class="c1"># complete traversal (counldn't terminate early)
</span></code></pre></div></div> <p>In-place: algorithms that do not use additional data structures to stroe data during execution, but instead modify the original input data structure directly.</p> <p>Space Complexity:</p> <ul> <li>In-place: O(1)</li> <li>Not in-place: O(n), additional array</li> </ul> <p>Why not in-place in this question?</p> <ul> <li>Position changes are very complex (lacking a fixed direction or fixed pattern). Cross movements are difficult to accomplish with simple (two) pointer opertaions</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sortedSquares</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">left_square</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">right_square</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">left_square</span> <span class="o">&lt;=</span> <span class="n">right_square</span><span class="p">:</span> <span class="c1"># write '&lt;' first, then check whether '=' works 
</span>                <span class="n">result</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">right_square</span>
                <span class="n">position</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reslut</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_square</span>
                <span class="n">position</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/">209. Minimum Size Subarray Sum</a></p> <p>In a loop (e.g., <code class="language-plaintext highlighter-rouge">while</code>, <code class="language-plaintext highlighter-rouge">for</code>):</p> <ul> <li>record the current valid result first</li> <li>update the state <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="n">sum_of_subarray</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">:</span>
 <span class="n">min_length</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">min_length</span><span class="p">,</span> <span class="n">fast</span> <span class="o">-</span> <span class="n">slow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> 
 <span class="c1"># record min_length
</span> <span class="n">sum_of_subarray</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span> 
 <span class="c1"># update the sum_of_subarray
</span> <span class="c1"># record nums[slow] based on slow first
</span> <span class="n">slow</span> <span class="o">+=</span> <span class="mi">1</span> 
 <span class="c1"># update slow
</span> <span class="c1"># use it, and then update it
</span></code></pre></div> </div> </li> </ul> <p><code class="language-plaintext highlighter-rouge">right - left</code> actually calculates the length of the interval <code class="language-plaintext highlighter-rouge">[left, right)</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minSubArrayLen</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">min_length</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">sub_of_subarray</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fast</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">sub_of_subarray</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span>

            <span class="k">while</span> <span class="n">sub_of_subarray</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">min_length</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">min_length</span><span class="p">,</span> <span class="n">fast</span> <span class="o">-</span> <span class="n">slow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">sum_of_array</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span>
                <span class="n">slow</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">min_length</span> <span class="k">if</span> <span class="n">min_length</span> <span class="o">!=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/spiral-matrix-ii/">59. Spiral Matrix II</a></p> <p><code class="language-plaintext highlighter-rouge">for _ in range(n)</code>: iterates n times</p> <p><code class="language-plaintext highlighter-rouge">for _ in range(left, right)</code>: iterates <code class="language-plaintext highlighter-rouge">right - left</code> times -&gt; <code class="language-plaintext highlighter-rouge">[left, right)</code></p> <p><code class="language-plaintext highlighter-rouge">for _ in range(left, right, -1)</code>: iterates <code class="language-plaintext highlighter-rouge">abs(right - left)</code> times -&gt; <code class="language-plaintext highlighter-rouge">(right, left]</code></p> <p><code class="language-plaintext highlighter-rouge">n * n</code> <code class="language-plaintext highlighter-rouge">matrix</code>: every row, every column has n elements</p> <p><code class="language-plaintext highlighter-rouge">[0] * n</code>: has n elements in total</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">generateMatrix</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">top</span> <span class="o">&lt;=</span> <span class="n">bottom</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">top</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># update the boundary when all elemenets in a certain row/column is handled
</span>            <span class="k">if</span> <span class="n">top</span> <span class="o">&gt;</span> <span class="n">bottom</span><span class="p">:</span>
                <span class="k">break</span>
                
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bottom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">bottom</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">bottom</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">top</span> <span class="o">&gt;</span> <span class="n">bottom</span><span class="p">:</span>
                <span class="k">break</span>
                
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">top</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">matrix</span>
</code></pre></div></div> <p><a href="https://leetcode.com/problems/count-of-range-sum/description/">327. Count of Range Sum</a></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
prefix_sum
nums = [1, 2, 3]
prefix_sum = [0, 1, 3, 6]
prefix_sum[i] = nums[0] + ... nums[i - 1]
prefix_sum[j + 1] = nums[0] + ... nums[i - 1] + nums[i] + ... + nums[j]
prefix_sum[j + 1] - prefix_sum[i] = nums[i] + ... nums[j]
</span><span class="sh">"""</span>
<span class="n">prefix_sum</span> <span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
    <span class="n">prefix_sum</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">prefix_sum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num</span><span class="p">)</span>
<span class="c1"># sum of interval [i, j] could be represented as prefix_sum[j + 1] - prefix_sum[i]
</span></code></pre></div></div>]]></content><author><name></name></author><category term="LeetCode"/><category term="LeetCode"/><summary type="html"><![CDATA[LeetCode problems related to Array]]></summary></entry></feed>